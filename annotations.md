[Вопросы для собеседования](README.md)

# Аннотации
+ [Что такое аннотации?](#что-такое-аннотации)
+ [Какие функции выполняют аннотации?](#какие-функции-выполняют-аннотации)
+ [Какие встроеные аннотации в java вы знаете?](#какие-встроеные-аннотации-в-java-вы-знаете)
+ [Что делают аннотации @retention, @documented, @target, @inherited?](#что-делают-аннотации-retention-documented-target-inherited)
+ [Что делают аннотации @override, @deprecated, @safeverargs, @suppressswarnings?](#что-делают-аннотации-override-deprecated-safeverargs-suppressswarnings)
+ [Какой жизненный цикл аннотации можно указать с помощью @retention?](#какой-жизненный-цикл-аннотации-можно-указать-с-помощью-retention)
+ [К каким элементам можно применять аннотации?](#к-каким-элементам-можно-применять-аннотации)
+ [Атрибуты каких типов допустимы в аннотациях?](#атрибуты-каких-типов-допустимы-в-аннотациях)
+ [Как создать свою аннотацию?](#как-создать-свою-аннотацию)
+ [Применение аннотаций?](#применение-аннотаций)
+ [Как узнать, какая была применена аннотация через рефлексию?](#как-узнать-какая-была-применена-аннотация-через-рефлексию)
+ [Какие есть ограничения у аннотаций?](#какие-есть-ограничения-у-аннотаций)


## Что такое аннотации?
Аннотации - это своего рода метатеги, которые добавляются к коду и применяются к
объявлению пакетов, классов, конструкторов, методов, полей, параметров и локальных
переменных. Аннотации всегда обладают некоторой информацией и связывают эти
"дополнительные данные" и все перечисленные конструкции языка.
Фактически аннотации представляют собой их дополнительные модификаторы,
применение которых не влечет за собой изменений ранее созданного кода.

[к оглавлению](#аннотации)

## Какие функции выполняют аннотации?
Аннотация выполняет следующие функции:
1. дает необходимую информацию для компилятора;
2. дает информацию различным инструментам для генерации другого кода,
конфигураций и т. д.;
3. может использоваться во время работы кода;
Самая часто встречаемая аннотация, которую встречал любой программист, даже
начинающий это @Override.

[к оглавлению](#аннотации)

## Какие встроеные аннотации в java вы знаете?
В языке Java SE определено несколько встроенных аннотаций, большинство из их
являются специализированными. Четыре типа @Retention, @Documented, @Target и
@Inherited - из пакета java.lang.annotation.
Из оставшиеся выделяются - @Override, @Deprecated, @SafeVarargs и
@SuppressWarnings - из пакета java.lang. Широкое использование аннотаций в
различных технологиях и фреймворках обуславливается возможностью сокращения
кода и снижения его связанности

[к оглавлению](#аннотации)

## Что делают аннотации @retention, @documented, @target, @inherited?
@Retention - эта аннотация предназначена для применения только в качестве
аннотации к другим аннотациям, позволяет указать жизненный цикл аннотации:
будет она присутствовать только в исходном коде, в скомпилированном файле, или
она будет также видна и в процессе выполнения. Выбор нужного типа зависит от
того, как вы хотите использовать аннотацию.
@Documented - это маркер-интерфейс, который сообщает инструменту, что
аннотация должна быть документирована.
@Target - эта аннотация задает тип объявления, к которым может быть применима
аннотация. Принимает один аргумент, который должен быть константой из
перечисления ElementType, это может быть поле, метод, тип и т.д. Например, чтобы
указать, что аннотация применима только к полям и локальным переменным:
@Targer({ ElementType.FIELD, ElementTyle.LOCAL_VARIABLE } )
@Inherited - это аннотация-маркер, которая может применяться в другом
объявление аннотации, она касается только тех аннотаций, что будут использованы в
объявлениях классов. Эта аннотация позволяет аннотации супер класса быть
унаследованной в подклассе.

[к оглавлению](#аннотации)

## Что делают аннотации @override, @deprecated, @safeverargs, @suppressswarnings?
@Override - аннотация-маркер, которая может применяться только к методам.
Метод, аннотированный как @Override, должен переопределять метод супер класса.
@Deprecated - указывает, что объявление устарело и должно быть заменено более
новой формой.
@SafeVarargs - аннотация-маркер, применяется к методам и конструкторам. Она
указывает, что никакие небезопасные действия, связанные с параметром
переменного количества аргументов, недопустимы. Применяется только к методам и
конструкторам с переменным количеством аргументов, которые объявлены как static
или final.
@SuppressWarnings - эта аннотация указывает, что одно или более
предупреждений, которые могут быть выданы компилятором следует подавить.

[к оглавлению](#аннотации)

## Какой жизненный цикл аннотации можно указать с помощью @retention?
Существует 3 возможных варианта чтобы указать где аннотация будет жить. Они
инкапсулированы в перечисление java.lang.annotation.RetentionPolicy. Это SOURSE,
CLASS, RUNTIME.
SOURCE - содержаться только в исходном файле и отбрасываются при компиляции.
CLASS - сохраняются в файле, однако они недоступны JVM во время выполнения.
RUNTIME - сохраняются в файле во время компиляции и остаются доступными JVM
во время выполнения.

[к оглавлению](#аннотации)

## К каким элементам можно применять аннотации?
Для того чтобы ограничить использование аннотации её нужно проаннотировать. Для
этого существует аннотация @Target.
@Target(ElementType.PACKAGE) - только для пакетов;
@Target(ElementType.TYPE) - только для классов;
@Target(ElementType.CONSTRUCTOR) - только для конструкторов;
@Target(ElementType.METHOD) - только для методов;
@Target(ElementType.FIELD) - только для атрибутов(переменных) класса;
@Target(ElementType.PARAMATER) - только для параметров метода;
@Target(ElementType.LOCAL_VARIABLE) - только для локальных переменных.
В случае если вы хотите, что бы ваша аннотация использовалась больше чем для
одного типа параметров, то можно указать @Target следующим образом:

[к оглавлению](#аннотации)

## Атрибуты каких типов допустимы в аннотациях?
Атрибуты могут иметь только следующие типы:
примитивы
String
Class или «any parameterized invocation of Class»
enum
annotation
массив элементов любого из вышеперечисленных типов
Последний пункт надо понимать как то, что допустимы только одномерные массивы.

[к оглавлению](#аннотации)

## Как создать свою аннотацию?
Все что нам нужно для создание своей аннотации, это создать файл About.java назвать его можно как угодно, но от этого названия будет зависеть имя вашей аннотации, если мы назвали его About.java то аннотация будет выглядеть так @About.
Напишем в созданном файле About.java следующий код:

``` java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface About{
    String info() default "";
}
```

По просту структура практически та же, что и у интерфейсов, только пишется @interface – указывает на то, что это аннотация
default – говорит про то, что метод по умолчанию будет возвращать определённое значение.

[к оглавлению](#аннотации)


## Применение аннотаций?
Автоматическая генерация вспомогательных файлов, вроде файлов дескрипторов развертывания или классов информации о bean-компонентах;
Автоматическая генерация кода для тестирования, регистрации, семантической обработки транзакций и так далее.

[к оглавлению](#аннотации)

## Как узнать, какая была применена аннотация через рефлексию?
Из объекта типа Class, Method, Field или Constructor можно получить кон­кретные аннотации, связанные с этим объектом, вызвав метод getAnnotation(). Его общая форма приведена ниже:
<A extends Annotation> getAnnotation(Class<A> тип_аннотации)
Здесь параметр тип_аннотации обозначает объект типа Class, представля­ющий требующуюся аннотацию. Этот метод возвращает ссылку на аннотацию.
Используя эту ссылку, можно получить значения, связанные с членами аннотации. Метод getAnnotation() возвращает пустое значение null, если аннотация не найдена.
В этом случае у искомой аннотации отсутствует аннотация @Retention, устанавливающая правило удержания RUNTIME.

[к оглавлению](#аннотации)

## Какие есть ограничения у аннотаций?
Во­первых, одна аннотация не может наследовать другую.
Во-вторых, все методы, объявленные в аннотации, должны быть без параметров. Кроме того, они должны возвращать один из перечисленных ниже типов:
 - примитивный тип наподобие int или double;
 - объект класса String или Class;
 - перечислимый тип;
 - тип другой аннотации;
 - массив одного из предыдущих типов.
Аннотации не могут быть обобщенными. Иными словами, они не могут принимать параметры типа. И наконец, при объявлении методов в аннотациях нельзя указывать оператор throws.

[к оглавлению](#аннотации)


[Вопросы для собеседования](README.md)
