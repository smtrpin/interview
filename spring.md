[Список всех вопросов по «Spring Framework»](spring.md)

# Основы Spring
+ [Что такое _«Spring»_?](#что-такое-spring)
+ [Из каких частей состоит _«Spring Framework»_?](#из-каких-частей-состоит-spring-framework)
+ [Назовите важные особенности _«Spring Framework»_](#назовите-важные-особенности-spring-framework)
+ [Объясните суть паттерна _«DI»_ или _«IOC»_](#объясните-суть-паттерна-di-или-ioc)
+ [Что предпочитаете использовать для конфигурации `Spring` - __xml__ или __аннотирование__?](#что-предпочитаете-использовать-для-конфигурации-spring-xml-или-аннотирование)
+ [Каковы преимущества применения _«Dependency Injection»_?](#каковы-преимущества-применения-dependency-injection)
+ [Какие _«IOC-контейнеры»_ Вы знаете?](#какие-ioc-контейнеры-вы-знаете)
+ [Какие существуют виды _«DI»_? Приведите примеры](#какие-существуют-виды-di-приведите-примеры)
+ [Назовите шаблоны проектирования, используемые в _«Spring Framework»_](#назовите-шаблоны-проектирования-используемые-в-spring-framework)
+ [Что такое `Bean`?](#что-такое-bean)
+ [Расскажите про `app-context.xml`](#расскажите-про-app-contextxml)
+ [Назовите способы настройки класса как `Spring Bean`](#назовите-способы-настройки-класса-как-spring-bean)
+ [Какие вы знаете `scope` у `Spring Bean`?](#какие-вы-знаете-scope-у-spring-bean)
+ [Что такое _«жизненный цикл»_ у `Spring Bean`?](#что-такое-жизненный-цикл-у-spring-bean)
+ [Объясните работу `BeanFactory` в `Spring`](#объясните-работу-beanfactory-в-spring)
+ [Как получить объекты `ServletContext` и `ServletConfig` внутри `Spring Bean`?](#как-получить-объекты-servletcontext-и-servletconfig-внутри-spring-bean)
+ [В чем роль `ApplicationContext` в `Spring`?](#в-чем-роль-applicationcontext-в-spring)
+ [Как создать `ApplicationContext` в программе Java?](#как-создать-applicationcontext-в-программе-java)
+ [Как выглядит типичная реализция метода используя `Spring`?](#как-выглядит-типичная-реализция-метода-используя-spring)
+ [Что такое _«связывание»_ в `Spring` и расскажите об аннотации `@Autowired`?](#что-такое-связывание-в-spring-и-расскажите-об-аннотации-autowired)
+ [Можем ли мы применить `@Autowired` с не сеттерами и не конструкторами методами?](#можем-ли-мы-применить-autowired-с-не-сеттерами-и-не-конструкторами-методами)
+ [Каковы различные типы автоматического связывания в `Spring`?](#каковы-различные-типы-автоматического-связывания-в-spring)
+ [Приведите пример часто используемых аннотаций `Spring`?](#приведите-пример-часто-используемых-аннотаций-spring)
+ [Является ли `Spring` бин потокобезопасным?](#является-ли-spring-бин-потокобезопасным)
+ [Можем ли мы иметь несколько файлов конфигурации `Spring`?](#можем-ли-мы-иметь-несколько-файлов-конфигурации-spring)
+ [Как внедрить _java.util.Properties_ в `Spring Bean`?](#как-внедрить-java.util.Properties-в-spring-bean)
+ [Как мы можем выбрать подходящий бин при помощи `application.properties`?](#как-мы-можем-выбрать-подходящий-бин-при-помощи-applicationproperties)
+ [Какая минимальная версия Java поддерживается в `Spring Boot 2` и `Spring 5`?](#какая-минимальная-версия-java-поддерживается-в-spring-boot-2-и-spring-5)

## Что такое _«Spring»_?

Пожалуй, самой трудной частью объяснения технологии `Spring` является точная ее
классификация. Обычно `Spring` описывается как легковесный каркас для построения
приложений на Java, но с этой формулировкой связаны два интересных момента.

+ Во-первых, `Spring` можно применять для построения любого приложения на языке
Java (например, автономных, неб-приложений или корпоративных (JEE) приложений
на Java), в отличие от многих других каркасов и, в частности, от каркаса Apache
Struts, предназначенного только для создания неб-приложений. 

+ Во-вторых, легковесный характер `Spring` на самом деле обозначает не количество классов или размеры
дистрибутива, а главный принцип всей философии `Spring` - минимальное воздействие.
`Spring` является легковесным каркасом в том смысле, что для использования
всех преимуществ ядра `Spring` вам придется внести лишь минимальные (если вообще
какие-нибудь) изменения в свой прикладной код, а если в какой-то момент вы решите
не пользоваться `Spring`, то и это сделать будет очень просто.

Обратите внимание на то, что речь идет только о ядре `Spring` - многие дополнительные
компоненты `Spring`, в том числе для доступа к данным, требуют более тесной
привязки к `Spring Framework`.

[к оглавлению](#основы-spring)

## Из каких частей состоит _«Spring Framework»_?

Основные модули:

+ __Основной контейнер__ - предоставляет основной функционал `Spring`. Главным
компонентом контейнера является BeanFactory - реализация паттерна _«Фабрика»_.
+ __BeanFactory__ позволяет разделить конфигурацию приложения и информацию о
зависимостях от кода.
+ __Spring context__ - конфигурационный файл, который предоставляет информация об
окружающей среде для `Spring`. Сюда входят такие enterprise-сервисы, как `JNDI`, `EJB`,
интернационализация, валиадция и т.п.
+ __Spring AOP__ - отвечает за интеграцию аспектно-ориентированного
программирования во фреймворк. `Spring AOP` обеспечивает сервис управления
транзакциями для _Spring-приложения_.
+ __Spring DAO__ - абстрактный уровень `Spring JDBC DAO` предоставляет иерархию
исключений и множество сообщений об ошибках для разных БД. Эта иерархия
упрощает обработку исключений и значительно уменьшает количество кода, которое
вам нужно было бы написать для таких операций, как, например, открытие и
закрытие соединения.
+ __Spring ORM__ - отвечает за интеграцию Spring и таких популярных ORM-фреймворков, как `Hibernate`, `iBatis` и `JDO`.
+ __Spring Web module__ - классы, которые помогают упростить разработку Web
(авторизация, доступ к бинам `Spring`-а из web).
+ __Spring MVC framework__ - реализация паттерна `MVC` для построения Web-приложений.

[к оглавлению](#основы-spring)

## Назовите важные особенности _«Spring Framework»_

`«Spring Framework»` обеспечивает решения многих задач, с которыми сталкиваются
Java-разработчики и организации, которые хотят создать информационную систему,
основанную на платформе Java.

Внедрение зависимостей (`DI`) и инверсия управления (`IoC`) позволяют писать
независимые друг от друга компоненты, что дает преимущества в командной
разработке, переносимости модулей и т.д. `Spring IoC` контейнер управляет жизненным циклом `Spring Bean` и настраивается
наподобие `JNDI  lookup` (поиска).

Проект `Spring` содержит в себе множество подпроектов, которые затрагивают
важные части создания софта, такие как вебсервисы, веб программирование, работа
с базами данных, загрузка файлов, обработка ошибок и многое другое. Всё это
настраивается в едином формате и упрощает поддержку приложения.

[к оглавлению](#основы-spring)

## Объясните суть паттерна _«DI»_ или _«IOC»_

Ядро каркаса `Spring Framework` основано на принципе инверсии управления (`inversion
of Control - IoC`), когда создание зависимостей между компонентами и управление
ими осуществляется внешним образом. 

Рассмотрим в качестве примера класс `Foo`, который зависит от экземпляра класса Bar для выполнения определенного вида
обработки. Традиционно экземпляр класса `Bar` получается в классе `Foo` с помощью
операции `new` или какой-нибудь разновидности фабричного класса. В соответствии с
принципом инверсии управления экземпляр класса `Bar` (или его подкласса) предоставляется
классу `Foo` во время выполнения некоторым внешним процессом. Такое
поведение во время выполнения привело к тому, что понятие инверсии управления
было переименовано Мартином Фаулером в более описательное понятие внедрения
зависимостей (`Dependency Injection - DI`).

Реализация внедрения зависимостей в `Spring` основана на двух ключевых понятиях
Java: компонентах `JavaBeans` и интерфейсах. Используя `Spring` в качестве поставщика
внедрения зависимостей, вы достигаете гибкости в определении конфигурации
зависимостей в своих приложениях самыми разными средствами (например, с помощью
ХМL-файлов, конфигурационных классов Java, аннотаций в прикладном коде
или нового способа определения компонентов `Groovy Beans`). Компоненты `JavaВeans`
(т.е. объекты `POJO`) предоставляют стандартный механизм для создания ресурсов
Java, которые можно конфигурировать самыми разными средствами вроде конструкторов
и методов установки.

[к оглавлению](#основы-spring)

## Что предпочитаете использовать для конфигурации `Spring` - __xml__ или __аннотирование__?

Предпочитаю аннотации, если кодовая база хорошо описывается такими элементами, как `@Service`, `@Component`, `@Autowired`.
Однако когда дело доходит до конфигурации, у меня нет каких-либо предпочтений. Я бы оставил этот вопрос команде.

[к оглавлению](#основы-spring)

## Каковы преимущества применения _«Dependency Injection»_?

К преимуществам `«DI»` можно отнести:
+ Сокращение объема связующего кода. Одним из самых больших плюсов `«DI»` является
возможность значительного сокращения объема кода, который должен быть написан
для связывания вместе различных компонентов приложения. Зачастую этот код
очень прост - при создании зависимости должен создаваться новый экземпляр
соответствующего объекта.
+ Упрощенная конфигурация приложения. За счет применения `«DI»` процесс
конфигурирования приложения значительно упрощается. Для конфигурирования
классов, которые могут быть внедрены в другие классы, можно использовать
аннотации или XML-файлы.
+ Возможность управления общими зависимостями в единственном репозитории. При
традиционном подходе к управлению зависимостями в общих службах, к которым
относятся, например, подключение к источнику данных, транзакция, удаленные
службы и т.п., вы создаете экземпляры (или получаете их из определенных
фабричных классов) зависимостей там, где они нужны - внутри зависимого класса.
Это приводит к распространению зависимостей по множеству классов в
приложении, что может затруднить их изменение. В случае использования DI вся
информация об общих зависимостях содержится в единственном репозитории (в
Spring есть возможность хранить эту информацию в XML-файлах или Java классах).
+ Улучшенная возможность тестирования. Когда классы проектируются для `«DI»`,
становится возможной простая замена зависимостей. Это особенно полезно при
тестировании приложения.
+ Стимулирование качественных проектных решений для приложений. Вообще
говоря, проектирование для DI означает проектирование с использованием
интерфейсов. Используя `Spring`, вы получаете в свое распоряжение целый ряд
средств `«DI»` и можете сосредоточиться на построении логики приложения, а не на
поддерживающей `«DI»` платформе.

[к оглавлению](#основы-spring)

## Какие _«IOC-контейнеры»_ Вы знаете?

`Spring` является _IoC-контейнером_. Помимо него существуют `HiveMind`, `Avalon`,
`PicoContainer` и т.д.

[к оглавлению](#основы-spring)

## Какие существуют виды _«DI»_? Приведите примеры

Существует два типа `DI`: 

+ __через сэттер__ (сначала бин, потом устанавливаем ему значение);
+ __через конструктор__ (с параметрами, то есть вызываем создание бина с параметром).

[к оглавлению](#основы-spring)

## Назовите шаблоны проектирования, используемые в _«Spring Framework»_

`«Spring Framework»` использует множество шаблонов проектирования, например:
+ `Singleton Pattern`: Creating beans with default scope.
+ `Factory Pattern`: Bean Factory classes
+ `Prototype Pattern`: Bean scopes
+ `Adapter Pattern`: Spring Web and Spring MVC
+ `Proxy Pattern`: Spring Aspect Oriented Programming support
+ `Template Method Pattern`: JdbcTemplate, HibernateTemplate etc
+ `Front Controller`: Spring MVC DispatcherServlet
+ `Data Access Object`: Spring DAO support
+ `Dependency Injection and Aspect Oriented Programming`

[к оглавлению](#основы-spring)

## Что такое `Bean`?

Термин «бин» (англ. `Bean`) - в `Spring` используется для ссылки на любой компонент,
управляемый контейнером. Обычно бины на определенном уровне придерживаются
спецификации `JavaBean`, но это не обязательно особенно если для связывания бинов
друг с другом планируется применять `Constructor Injection`. Для получения экземпляра
бина используется `ApplicationContext`. `IoC` контейнер управляет жизненным циклом
спринг бина, областью видимости и внедрением.

[к оглавлению](#основы-spring)

## Расскажите про `app-context.xml`

Конфигурационный файл спринг определяет все бины, которые будут
инициализированы в `Spring Context`. При создании экземпляра `Spring
ApplicationContext` будет прочитан конфигурационный `xml` файл и выполнены
указанные в нем необходимые инициализации. Отдельно от базовой конфигурации, в
файле могут содержаться описание перехватчиков (`interceptors`), `view resolvers`,
настройки локализации и др...

[к оглавлению](#основы-spring)

## Назовите способы настройки класса как `Spring Bean`

Существует несколько способов работы с классами в `Spring`:

+ `XML` конфигурация;
+ `Groovy` конфигурация;
+ `Annotation based` конфигурация. Можно использовать внутри кода аннотации
`@Component`, `@Service`, `@Repository`, `@Controller` для указания классов в качестве
спринг бинов.

[к оглавлению](#основы-spring)

## Какие вы знаете `scope` у `Spring Bean`?

В `Spring` предусмотрены различные области времени действия бинов:

+ `singleton` - может быть создан только один экземпляр бина. Этот тип используется
спрингом по умолчанию, если не указано другое. Следует осторожно использовать
публичные свойства класса, т.к. они не будут потокобезопасными.
+ `prototype` - создается новый экземпляр при каждом запросе.
+ `request` - аналогичен prototype, но название служит пояснением к использованию
бина в веб приложении. Создается новый экземпляр при каждом HTTP request.
+ `session` - новый бин создается в контейнере при каждой новой HTTP сессии.
+ `global-session`- используется для создания глобальных бинов на уровне сессии для
`Portlet`  приложений.

[к оглавлению](#основы-spring)

## Что такое _жизненный цикл_ у `Spring Bean`?

Жизненный цикл `Spring` бина - время существования класса. Spring бины
инициализируются при инициализации `Spring` контейнера и происходит внедрение
всех зависимостей. Когда контейнер уничтожается, то уничтожается и всё
содержимое. Если нам необходимо задать какое-либо действие при инициализации и
уничтожении бина, то нужно воспользоваться методами `init()` и `destroy()`. Для этого
можно использовать аннотации `@PostConstruct` и `@PreDestroy()` или `xml` конфигурацию.

[к оглавлению](#основы-spring)

## Объясните работу `BeanFactory` в `Spring`

`BeanFactory` - это реализация паттерна «Фабрика», его функицональность покрывает
создание бинов. Так как эта фабрика знает многое об объектах приложения, то она
может создавать связи между объектами на этапе создания экземпляра. Существует
несколько реализаций `BeanFactory`, самая используемся -
_""org.springframework.beans.factory.xml.XmlBeanFactory""_. Она загружает бины на
основе конфигурационного XML-файла. 

[к оглавлению](#основы-spring)

## Как получить объекты `ServletContext` и `ServletConfig` внутри `Spring Bean`?

Доступны два способа для получения основных объектов контейнера внутри бина:

+ Реализовать один из `Spring*Aware` (`ApplicationContextAware`, `ServletContextAware`, `ServletConfigAware` и др.) интерфейсов.
+ Использовать автоматическое связывание `@Autowired` в спринг. Способ работает внутри контейнера спринг:

```java
@Autowired
ServletContext servletContext;
```

[к оглавлению](#основы-spring)

## В чем роль `ApplicationContext` в `Spring`?

В то время, как `BeanFactory` используется в простых приложениях, `Application Context` - это более сложный контейнер. Как и `BeanFactory` он может быть использован для
загрузки и связывания бинов, но еще он предоставляет:
+ возможность получения текстовых сообщений, в том числе поддержку
интернационализации;
+ общий механизм работы с ресурсами;
+ события для бинов, которые зарегестрированы как слушатели.

Из-за большей функциональности рекомендуется использование `Application Context`
вместо `BeanFactory`. Последний используется только в случаях нехватки ресурсов,
например при разработке для мобильных устройств.

[к оглавлению](#основы-spring)

## Как создать `ApplicationContext` в программе Java?

В независимой Java программе `ApplicationContext` можно создать следующим образом:
+ `AnnotationCongApplicationContext` - при использовании `Spring` в качестве
автономного приложения можно создать инициализировать контейнер с помощью
аннотаций. Пример:
```java
ApplicationContext context = new AnnotationConfigApplicationContext("bean.xml");
```

+ `ClassPathXmlApplicationContext` - получает информацию из xml-файла, находящегося
в `classpath`. Пример:
```java
ApplicationContext context = new ClassPathXmlApplicationContext("bean.xml");
```

+ `FileSystemXmlApplicationContext` - получает информацию из xml-файла, но с
возможностью загрузки файла конфигурации из любого места файловой системы.
Пример:
```java
ApplicationContext context = new FileSystemXmlApplicationContext("bean.xml");
```

+ `XmlWebApplicationContext` - получает информацию из xml-файла за пределами webприложения.

[к оглавлению](#основы-spring)

## Как выглядит типичная реализция метода используя `Spring`?

Для типичного `Spring`-приложения нам необходимы следующие файлы:
+ Интерфейс, описывающий функционал приложения
+ Реализация интерфейса, содержащая свойства, сэттеры-гэттеры, функции и т.п.
+ Конфигурационный _XML_-файл `Spring`'а.
+ Клиентское приложение, которое использует функцию.

[к оглавлению](#основы-spring)

## Что такое _«связывание»_ в `Spring` и расскажите об аннотации `@Autowired`?

Процесс внедрения зависимостей в бины при инициализации называется `Spring Bean
Wiring`. Считается хорошей практикой задавать явные связи между зависимостями, но
в `Spring` предусмотрен дополнительный механизм связывания `@Autowired`. Аннотация
может использоваться над полем или методом для связывания по типу. Чтобы
аннотация заработала, необходимо указать небольшие настройки в конфигурационном
файле спринг с помощью элемента _context:annotation-cong_.

[к оглавлению](#основы-spring)

## Можем ли мы применить `@Autowired` с не сеттерами и не конструкторами методами?

Да, конечно.
`@Autowired` может использоваться вместе с конструкторами, сеттерами или любым другими методами. Когда `Spring` находит `@Autowired` на методе, 
`Spring` автоматически вызовет этот метод, после создания экземпляра бина. В качестве аргументов, будут подобраны подходящие объекты из контекста `Spring`.

[к оглавлению](#основы-spring)

## Каковы различные типы автоматического связывания в `Spring`?

Существует четыре вида связывания в `Spring`:

+ _autowire byName_,
+ _autowire byType_,
+ _autowire by constructor_,
+ _autowiring by @Autowired and @Qualier annotations_.

[к оглавлению](#основы-spring)

## Приведите пример часто используемых аннотаций `Spring`?

+ `@Controller` - класс фронт контроллера в проекте Spring MVC.
+ `@RequestMapping` - позволяет задать шаблон маппинга URI в методе обработчике
контроллера.
+ `@ResponseBody` - позволяет отправлять Object в ответе. Обычно используется для
отправки данных формата XML или JSON.
+ `@PathVariable` - задает динамический маппинг значений из URI внутри аргументов
метода обработчика.
+ `@Autowired` - используется для автоматического связывания зависимостей в spring
beans.
+ `@Qualier` - используется совместно с @Autowired для уточнения данных связывания,
когда возможны коллизии (например одинаковых имен\типов).
+ `@Service` - указывает что класс осуществляет сервисные функции.
+ `@Scope` - указывает scope у spring bean.
+ `@Conguration`, `@ComponentScan` и `@Bean` - для _java based congurations_.
+ `AspectJ` аннотации для настройки _aspects_ и _advices_, `@Aspect`, `@Before`, `@After`,`@Around`, `@Pointcut` и др.

[к оглавлению](#основы-spring)

## Является ли `Spring` бин потокобезопасным?

По умолчанию бин задается как _синглтон_ в `Spring`. Таким образом все публичные
переменные класса могут быть изменены одновременно из разных мест. Так что -
нет, не является. Однако поменяв область действия бина на `request`, `prototype`, `session`
он станет потокобезопасным, но это скажется на производительности

[к оглавлению](#основы-spring)

## Можем ли мы иметь несколько файлов конфигурации `Spring`?

С помощью указания `contextCongLocation `можно задать несколько файлов
конфигурации `Spring`. Параметры указываются через запятую или пробел.

Поддерживается возможность указания нескольких корневых файлов конфигурации
`Spring`.

Файл конфигурации можно также импортировать:
```
<beans:import resource="spring-jdbc.xml"/>
```

[к оглавлению](#основы-spring)

## Как внедрить _java.util.Properties_ в `Spring Bean`?

Для возможности использования `Spring EL` для внедрения свойств (`properties`) в различные бины необходимо определить `propertyConfigure bean`, который будет загружать 
файл свойств.
```
<bean id="propertyConfigurer"
  class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">
    <property name="location" value="/WEB-INF/application.properties" />
</bean> 
 
<bean class="com.journaldev.spring.EmployeeDaoImpl">
    <property name="maxReadResults" value="${results.read.max}"/>
</bean>
```
Или через аннотации:
```
@Value("${maxReadResults}") 
private int maxReadResults;
```

[к оглавлению](#основы-spring)

## Как мы можем выбрать подходящий бин при помощи `application.properties`?

Рассмотрим пример:

```java
interface GreetingService {
    public String sayHello();
}
```

И два компонента:
```java
@Component(value=""real"")
class RealGreetingService implements GreetingService {
    public String sayHello() {
        return ""I'm real"";
    }
}

@Component(value=""mock"")
class MockGreetingService implements GreetingService {
    public String sayHello() {
        return ""I'm mock"";
    }
}
```

Тогда в `application.properties` добавим свойство:
```java
application.greeting: real
```

Воспользуемся данным решением:
```java
@RestController
public class WelcomeController {
    @Resource(name=""${application.greeting}"")
    private GreeterService service1;
}
```

[к оглавлению](#основы-spring)

## Какая минимальная версия Java поддерживается в `Spring Boot 2` и `Spring 5`?

`Spring 5.0` и `Spring Boot 2.0` поддерживают _Java 8_ и более поздние версии.

[к оглавлению](#основы-spring)
