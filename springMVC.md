[Список всех вопросов по «Spring Framework»](spring.md)

# Spring MVC
+ [Можем ли мы послать объект как ответ метода обработчика контроллера?](#можем-ли-мы-послать-объект-как-ответ-метода-обработчика-контроллера)
+ [Что такое контроллер в `Spring MVC`?](#что-такое-контроллер-в-spring-mvc)
+ [Какая разница между `@Component`, `@Service` и `@Repository`?](#какая-разница-между-component-service-и-repository)
+ [Для чего нужен `Component Scan`?](#для-чего-нужен-component-scan)
+ [Как вы добавите `Component Scan` в `Spring Boot`?](#как-вы-добавите-component-scan-в-spring-boot)
+ [Расскажите, что Вы знаете о `DispatcherServlet` и `ContextLoaderListener`?](#расскажите-что-вы-знаете-о-dispatcherservlet-и-contextloaderlistener)
+ [Что такое `ViewResolver` в `Spring`?](#что-такое-viewresolver-в-spring)
+ [Что такое `MultipartResolver` и когда его использовать?](#что-такое-multipartresolver-и-когда-его-использовать)
+ [Как обрабатывать исключения в `Spring MVC Framework`?](#как-обрабатывать-исключения-в-spring-mvc-framework)
+ [Каковы минимальные настройки, чтобы создать приложение `Spring MVC`?](#каковы-минимальные-настройки-чтобы-создать-приложение-spring-mvc)
+ [Как бы вы связали `Spring MVC Framework` и архитектуру `MVC`?](#как-бы-вы-связали-spring-mvc-framework-и-архитектуру-mvc)
+ [Как добиться локализации в приложениях `Spring MVC`?](#как-добиться-локализации-в-приложениях-spring-mvc)
+ [Как мы можем использовать `Spring` для создания веб-службы `RESTful`, возвращающей `JSON`?](#как-мы-можем-использовать-spring-для-создания-веб-службы-restful-возвращающей-json)
+ [Как проверить (валидировать) данные формы в `Spring Web MVC Framework`?](#как-проверить-валидировать-данные-формы-в-spring-web-mvc-framework)
+ [Что Вы знаете о `Spring MVC Interceptor`?](#что-вы-знаете-о-spring-mvc-interceptor)
+ [В чём разница между `@Controller` и `@RestController`?](#в-чём-разница-между-controller-и-restcontroller)
+ [Почему иногда мы используем `@ResponseBody`, а иногда `ResponseEntity`?](#почему-иногда-мы-используем-responsebody-а-иногда-responseentity)
+ [Объясните назначение аннотаций @PathVariable, @RequestBody, @ResponseBody, @RequestParam, @RequestHeader, @RequestPart](#объясните-назначение-аннотаций-@PathVariable,-@RequestBody,-@ResponseBody,-@RequestParam,-@RequestHeader,-@RequestPart)
+ [Как добавить поддержку `Spring` в Web-приложение?](#как-добавить-поддержку-spring-в-web-приложение)
+ [Можно ли использовать `xyz.xml` вместо `applicationContext.xml`?](#можно-ли-использовать-xyzxml-вместо-applicationcontextxml)
+ [В чем различие между `web.xml` и `Spring Context - servlet.xml`?](#в-чем-различие-между-webxml-и-spring-context-servletxml)

## Можем ли мы послать объект как ответ метода обработчика контроллера?

Да, это возможно. Для этого используется аннотация `@ResponseBody`. Так можно
отправлять ответы в виде `JSON`, `XML` в `restful` веб сервисах.

[к оглавлению](#spring-mvc)

## Что такое контроллер в `Spring MVC`?

Ключевым интерфейсом в `Spring MVC` является `Controller`. Контроллер обрабатывает
запросы к действиям, осуществляемые пользователями в пользовательском
интерфейсе, взаимодействуя с уровнем обслуживания, обновляя модель и направляя
пользователей на соответствующие представления в зависимости от результатов
выполнения. `Controller` - управление, связь между моделью и видом.

Основным контроллером в` Spring MVC` является
_org.springframework.web.servlet.DispatcherServlet_. Задается аннотацией `@Controller` и
часто используется с аннотацией `@RequestMapping`, которая указывает какие запросы
будут обрабатываться этим контроллером.

[к оглавлению](#spring-mvc)

## Какая разница между `@Component`, `@Service` и `@Repository`?

+ `@Component` - используется для указания класса в качестве компонента `Spring`. При
использовании поиска аннотаций, такой класс будет сконфигурирован как `Spring Bean`.
+ `@Controller` - специальный тип класса, применяемый в MVC приложениях.
Обрабатывает запросы и часто используется с аннотацией `@RequestMapping`.
+ `@Repository` - указывает, что класс используется для работы с поиском, получением и
хранением данных. Аннотация может использоваться для реализации шаблона `DAO`.
+ `@Service` - указывает, что класс является сервисом для реализации бизнес логики (на
самом деле не отличается от `Component`, но просто помогает разработчику указать
смысловую нагрузку класса).

Для указания контейнеру на класс-бин можно использовать любую из этих аннотаций.
Но различные имена позволяют различать назначение того или иного класса.

[к оглавлению](#spring-mvc)

## Для чего нужен `Component Scan`?

Первый шаг для описания `Spring Beans` это добавление аннотации — `@Component`, или `@Service`, или `@Repository`.
Однако, `Spring` ничего не знает об этих бинах, если он не знает где искать их. То, что скажет `Spring` где искать эти бины и называется `Component Scan.` 
В `@ComponentScan` вы указываете пакеты, которые должны сканироваться.
`Spring` будет искать бины не только в пакетах для сканирования, но и в их подпакетах.

[к оглавлению](#spring-mvc)

## Как вы добавите `Component Scan` в `Spring Boot`?

```java
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```
`@SpringBootApplication` определяет автоматическое сканирование пакета, где находится класс `Application`
Всё будет в порядке, ваш код целиком находится в указанном пакете или его подпакетах.
Однако, если необходимый вам компонент находится в другом пакете, вы должны использовать дополнительно аннотацию `@ComponentScan`, где перечислите все 
дополнительные пакеты для сканирования

[к оглавлению](#spring-mvc)

## Расскажите, что Вы знаете о `DispatcherServlet` и `ContextLoaderListener`?

`DispatcherServlet` - сервлет диспетчер. Этот сервлет анализирует запросы и направляет
их соответствующему контроллеру для обработки. В `Spring MVC` класс
`DispatcherServlet` является центральным сервлетом, который получает запросы и
направляет их соответствующим контроллерам. В приложении `Spring MVC` может
существовать произвольное количество экземпляров `DispatcherServlet`,
предназначенных для разных целей (например, для обработки запросов
пользовательского интерфейса, запросов веб-служб REST и т.д.). Каждый экземпляр
`DispatcherServlet` имеет собственную конфигурацию `WebApplicationContext`, которая
определяет характеристики уровня сервлета, такие как контроллеры, поддерживающие
сервлет, отображение обработчиков, распознавание представлений,
интернационализация, оформление темами, проверка достоверности, преобразование
типов и форматирование и т.п.

`ContextLoaderListener` - слушатель при старте и завершении корневого класса Spring
`WebApplicationContext`. Основным назначением является связывание жизненного
цикла `ApplicationContext` и `ServletContext`, а так же автоматического создания
`ApplicationContext`. Можно использовать этот класс для доступа к бинам из различных
контекстов спринг. Настраивается в _web.xml_.

[к оглавлению](#spring-mvc)

## Что такое `ViewResolver` в `Spring`?

`ViewResolver` - распознаватель представлений. Интерфейс `ViewResolver` в `Spring MVC`
(из пакета _org.springframework.web.servlet_) поддерживает распознавание
представлений на основе логического имени, возвращаемого контроллером. Для
поддержки различных механизмов распознавания представлений предусмотрено
множество классов реализации. 
Например, класс `UrlBasedViewResolver` поддерживает
прямое преобразование логических имен в URL. Класс
`ContentNegotiatingViewResolver` поддерживает динамическое распознавание
представлений в зависимости от типа медиа, поддерживаемого клиентом (XML, PDF,
JSON и т.д.). Существует также несколько реализаций для интеграции с различными
технологиями представлений, такими как _FreeMarker_ (`FreeMarkerViewResolver`),
_Velocity_ (`VelocityViewResolver`) и _JasperReports_ (`JasperReportsViewResolver`).

`InternalResourceViewResolver` - реализация `ViewResolver`, которая позволяет находить
представления, которые возвращает контроллер для последующего перехода к нему.
Ищет по заданному пути, префиксу, суффиксу и имени.

[к оглавлению](#spring-mvc)

## Что такое `MultipartResolver` и когда его использовать?

Интерфейс `MultipartResolver` используется для загрузки файлов. Существуют две
реализации: `CommonsMultipartResolver` и `StandardServletMultipartResolver`, которые
позволяют фреймворку загружать файлы. По умолчанию этот интерфейс не
включается в приложении и необходимо указывать его в файле конфигурации. После
настройки любой запрос о загрузке будет отправляться этому интерфейсу.

[к оглавлению](#spring-mvc)

## Как обрабатывать исключения в `Spring MVC Framework`?

В `Spring MVC` интерфейс `HandlerExceptionResolver` (из пакета
_org.springframework.web.servlet_) предназначен для работы с непредвиденными
исключениями, возникающими во время выполнения обработчиков. По умолчанию
`DispatcherServlet` регистрирует класс `DefaultHandlerExceptionResolver` (из пакета
_org.springframework.web.servlet.mvc.support_). Этот распознаватель обрабатывает
определенные стандартные исключения `Spring MVC`, устанавливая специальный код
состояния ответа. Можно также реализовать собственный обработчик исключений,
аннотировав метод контроллера с помощью аннотации `@ExceptionHandler` и передав
ей в качестве атрибута тип исключения. В общем случае обработку исключений можно
описать таким образом:
+ `Controller Based` - указать методы для обработки исключения в классе контроллере.
Для этого нужно пометить такие методы аннотацией `@ExceptionHandler`.
+ `Global Exception Handler` - для обработки глобальных исключений `Spring`
предоставляет аннотацию `@ControllerAdvice`.
+ `HandlerExceptionResolver implementation` – общие исключений большая часть
времени обслуживают статические страницы. `Spring Framework` предоставляет
интерфейс `HandlerExceptionResolver`, который позволяет задать глобального
обработчика исключений. Реализацию этого интерфейса можно использовать для
создания собственных глобальных обработчиков исключений в приложении.

[к оглавлению](#spring-mvc)

## Каковы минимальные настройки, чтобы создать приложение `Spring MVC`?

Для создания простого `Spring MVC` приложения необходимо пройти следующие шаги:

+ Добавить зависимости `spring-context` и `spring-webmvc` в проект.
+ Указать `DispatcherServlet` в _web.xml_ для обработки запросов внутри приложения.
+ Задать определение `Spring Bean` (аннотацией или в xml).
+ Добавить определение `View Resolver` для представлений.
+ Настроить класс контроллер для обработки клиентских запросов.

[к оглавлению](#spring-mvc)

## Как бы вы связали `Spring MVC Framework` и архитектуру `MVC`?

__Модель__ (`Model`) - выступает любой Java bean в Spring. Внутри класса могут быть
заданы различные атрибуты и свойства для использования в представлении.

__Преставление__ (`View`) - _JSP_ страница, HTML файл и т.п. служат для отображения
необходимой информации пользователю. Представление передает обработку запросов
к диспетчеру сервлетов (контроллеру).

__DispatcherServlet__ (`Controller`) - это главный контроллер в приложении `Spring MVC`,
который обрабатывает все входящие запросы и передает их для обработки в различные
методы в контроллеры.

[к оглавлению](#spring-mvc)

## Как добиться локализации в приложениях `Spring MVC`?

`Spring MVC` предоставляет очень простую и удобную возможность локализации
приложения. Для этого необходимо сделать следующее:

+ Создать файл _resource bundle_, в котором будут заданы различные варианты
локализированной информации.
+ Определить `messageSource`e в конфигурации Spring используя классы
ResourceBundleMessageSource или ResourceBundleMessageSource.
+ Определить `localceResolver` класса`CookieLocaleResolver` для включения
возможности переключения локали.

С помощью элемента _spring:message_, `DispatcherServlet` будет определять в каком
месте необходимо подставлять локализированное сообщение в ответе.

[к оглавлению](#spring-mvc)

## Как мы можем использовать `Spring` для создания веб-службы `RESTful`, возвращающей `JSON`?

`Spring Framework` позволяет создавать `RESTful`-веб сервисы и возвращать данные в
формате JSON. Spring обеспечивает интеграцию с `Jackson JSON API` для возможности
отправки `JSON` ответов в `RESTful` web сервисе. Для отправки ответа в формате `JSON` из
`Spring MVC` приложения необходимо произвести некоторые дополнительные настройки;
+ Добавить зависимости `Jackson JSON`;
+ Настроить бин `RequestMappingHandlerAdapter` в файле конфигурации `Spring` и задать
свойство `messageConverters` на использование бина `MappingJackson2HttpMessageConverter`;
+ В контроллере указать с помощью аннотации `@ResponseBody` возвращение Object.

[к оглавлению](#spring-mvc)

## Как проверить (валидировать) данные формы в `Spring Web MVC Framework`?

`Spring` поддерживает аннотации валидации из __JSR-303__, а так же возможность создания
своих реализаций классов валидаторов.

[к оглавлению](#spring-mvc)

## Что Вы знаете о `Spring MVC Interceptor`?

Перехватчики в `Spring` (`Spring Interceptors`) являются аналогом `Servlet Filter` и
позволяют перехватывать запросы клиента и обрабатывать их. Перехватить запрос
клиента можно в трех местах: `preHandle`, `postHandle` и `afterCompletion`.
+ `preHandle` - метод используется для обработки запросов, которые еще не были
переданы в метода обработчик контроллера. Должен вернуть true для передачи
следующему перехватчику или в `handler method`. _False_ укажет на обработку запроса
самим обработчиком и отсутствию необходимости передавать его дальше. Метод
имеет возможность выкидывать исключения и пересылать ошибки к представлению.
+ `postHandle` - вызывается после `handler method`, но до обработки `DispatcherServlet`
для передачи представлению. Может использоваться для добавления параметров в
объект `ModelAndView`.
+ `afterCompletion` - вызывается после отрисовки представления.
Для создания обработчика необходимо расширить абстрактный класс
`HandlerInterceptorAdapter` или реализовать интерфейс `HandlerInterceptor`. Так же
нужно указать перехватчики в конфигурационном файле `Spring`.

[к оглавлению](#spring-mvc)

## В чём разница между `@Controller` и `@RestController`?

_`@RestController` = `@Controller` + `@ResponseBody`_;

`@RestController` превращает помеченный класс в `Spring`-бин. Этот бин для конвертации входящих/исходящих данных использует _Jackson message converter_. 
Как правило целевые данные представлены в `json` или `xml`.

[к оглавлению](#spring-mvc)

## Почему иногда мы используем `@ResponseBody`, а иногда `ResponseEntity`?

`ResponseEntity` необходим, только если мы хотим кастомизировать ответ, добавив к нему статус ответа. Во всех остальных случаях будем использовать `@ResponseBody.`

```java
@GetMapping(value=”/resource”) 
@ResponseBody 
public Resource sayHello() { return resource; }

@PostMapping(value=”/resource”) 
public ResponseEntity createResource() { 
    ….
return ResponseEntity.created(resource).build(); 
}
```
Стандартные HTTP коды статусов ответов, которые можно использовать:
+ 200 — SUCCESS
+ 201 — CREATED
+ 404 — RESOURCE NOT FOUND
+ 400 — BAD REQUEST
+ 401 — UNAUTHORIZED
+ 500 — SERVER ERROR

Для `@ResponseBody` единственные состояния статуса это SUCCESS(200), если всё хорошо и SERVER ERROR(500), если произошла какая-либо ошибка.
Допустим мы что-то создали и хотим отправить статус CREATED(201). В этом случае мы используем ёResponseEntityё.

[к оглавлению](#spring-mvc)

## Объясните назначение аннотаций @PathVariable, @RequestBody, @ResponseBody, @RequestParam, @RequestHeader, @RequestPart
`@PathVariable`

В ряде случаев, удобно адресовать метода контроллера, включая в путь значения каких-то параметров, например, http://mysite.ru/pages/5. 
Для того, чтобы обрабатывать такие запросы методами контроллера, нужно использовать следующую конструкцию в контроллере:

```java
@RequestMapping(value = "/pages/{id}")
public String loadPage(@PathVariable(value = "id") Long id) {
  //---
}
```

Здесь в аннотации @RequestMapping в адресе использована конструкция {id}, определяющая место параметра в адресной строке. 
В параметрах метода использована дополнительная аннотация @PathVariable, указывающая на то, что данный параметр получается из адресной строки. 
Имя переменной не обязательно должно совпадать с тем, как оно обозначено в @RequestMapping. Поэтому указывается @PathVariable(value = "id"). 
Это позволяет очевидным образом использовать несколько параметров в одной адресной строке, например, @RequestMapping(value = "users/{userId}/pages/{pageId}").


`@RequestBody`

HTTP-запрос кроме заголовков и параметров имеет также основную часть - тело запроса. Её содержимое также может быть распознано как параметр в методе контроллера. 
Для того, чтобы это произошло, необходимо указать @RequestBody в объявлении этого параметра:

```java
@RequestMapping(value = "/page", method = RequestMethod.POST)
public String savePage(@RequestBody String pageContent) {
  //---
}
```

Поскольку происходит распознавание всего тела запроса как объекта, нет возможности объявить более чем один параметр с аннотацией @RequestBody. 
Поэтому, если требуется получить от клиента несколько объектов, приходится создавать на сервере специальный "транспортный класс", 
объединяющий эти объекты в одну структуру - и принимать от клиента объект-экземпляр такого класса.
Существует возможность настроить распознавание тела запроса в конфигурационных файлах. Информацию об этом нужно включить в этот документ.


`@RequestParam`
 
Аннотированные параметры связаны с определенными параметрами запроса сервлета. Значения параметров преобразуются в тип аргумента объявленного метода. 
Эта аннотация указывает, что параметр метода должен быть привязан к параметру веб-запроса.

Например, запрос Angular для Spring RequestParam (s) будет выглядеть следующим образом:

$http.post('http://localhost:7777/scan/l/register?username="Johny"&password="123123"&auth=true')
      .success(function (data, status, headers, config) {
                        ...
                    })
Конечная точка с RequestParam:

```java
@RequestMapping(method = RequestMethod.POST, value = "/register")
public Map<String, String> register(Model uiModel,
                                    @RequestParam String username,
                                    @RequestParam String password,
                                    @RequestParam boolean auth,
                                    HttpServletRequest httpServletRequest) {...
```
                                    
`@RequestHeader`

Иногда вам требуется получить в качестве параметров вашего метода в контроллере непосредственно заголовки HTTP-запроса. Заголовки могут выглядеть так:

Host                    localhost:8080
Accept                  text/html,application/xhtml+xml,application/xml;q=0.9
Accept-Language         fr,en-gb;q=0.7,en;q=0.3
Accept-Encoding         gzip,deflate
Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive              300

В методе можно запросить значения заголовков следующим образом:

```java
@RequestMapping("/displayHeaderInfo")
public void displayHeaderInfo(@RequestHeader("Accept-Encoding") String encoding,
                              @RequestHeader("Keep-Alive") long keepAlive)  {
  //...
}
```

`@RequestPart`

Аннотация предназначена для обращения к отдельным частям multipart-запроса.
Поддерживаемые типы аргументов метода включают MultipartFile в сочетании с абстракцией MultipartResolver в Spring, javax.servlet.http.Part в сочетании с многочастными запросами Servlet 3.0,
или для любого другого аргумента метода, содержимое части передается через HttpMessageConverter с учетом заголовка «Content-Type» части запроса.
Это аналогично тому, что @RequestBody делает для разрешения аргумента на основе содержимого запроса, не состоящего из нескольких частей.

Обратите внимание, что аннотация @RequestParam может также использоваться для связывания части запроса «multipart / form-data» с аргументом метода, поддерживающим те же типы аргументов метода.
Основное отличие состоит в том, что когда аргумент метода не является String или необработанным MultipartFile / Part,
@RequestParam полагается на преобразование типов через зарегистрированный конвертер или PropertyEditor, тогда как RequestPart полагается на HttpMessageConverters, 
принимая во внимание заголовок «Content-Type» части запроса. RequestParam, вероятно, будет использоваться с полями формы имя-значение, в то время как RequestPart, вероятно, 
будет использоваться с частями, содержащими более сложное содержимое, например, JSON, XML).

```java
@Target(value=PARAMETER)
@Retention(value=RUNTIME)
@Documented
public @interface RequestPart
```

[к оглавлению](#spring-mvc)

## Как добавить поддержку `Spring` в Web-приложение?

Достаточно просто указать `ContextLoaderListener` в _web.xml_ файле приложения.

[к оглавлению](#spring-mvc)

## Можно ли использовать `xyz.xml` вместо `applicationContext.xml`?

`ContextLoaderListener` - это `ServletContextListener`, который инициализируется когда
ваше web-приложение стартует. По-умолчанию оно загружает файл _WEBINF/applicationContext.xml_. Вы можете изменить значение по-умолчанию, указав
параметр `contextCongLocation`

[к оглавлению](#spring-mvc)

## В чем различие между `web.xml` и `Spring Context - servlet.xml`?

`web.xml` — Метаданные и конфигурация любого веб-приложения, совместимого с _Java EE_. _Java EE_ стандарт для веб-приложений.

`servlet.xml` — файл конфигурации, специфичный для `Spring Framework`.

[к оглавлению](#spring-mvc)

[Вопросы для собеседования](README.md)
