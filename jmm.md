[Вопросы для собеседования](README.md)

# Модель памяти Java 
+ [Что произойдет со сборщиком мусора, если во время выполнения метода finalize некоторого объекта произойдет исключение?](#что-произойдет-со-сборщиком-мусора-если-во-время-выполнения-метода-finalize-некоторого-объекта-произойдет-исключение)
+ [Типы ссылок в Java?](#типы-ссылок-в-java)
+ [Взаимодействие сборщика мусора и ссылок](#взаимодействие-сборщика-мусора-и-ссылок)
+ [Какие переменные не собираются сборщиком мусора?](#какие-переменные-не-собираются-сборщиком-мусора)
+ [Когда вызывается finalize()?](#когда-вызывается-finalize)
+ [Для чего на самом деле нужен finalize?](#для-чего-на-самом-деле-нужен-finalize)
+ [Для чего нужно System.runFinalization()?](#для-чего-нужно-systemrunfinalization)
+ [Приведите пример совместной работы finalize и weak references?](#приведите-пример-совместной-работы-finalize-и-weak-references)
+ [Расскажите об особенностях метода finalize](#расскажите-об-особенностях-метода-finalize)
+ [Расскажите прием уменьшения пауз GC](#расскажите-прием-уменьшения-пауз-gc)
+ [Принятый способ использования finalize при работе со стандартными объектами, например, файлами?](#принятый-способ-использования-finalize-при-работе-со-стандартными-объектами-например-файлами)
+ [Пригодность для запуска сборщика мусора (общий случай)](#пригодность-для-запуска-сборщика-мусора-общий-случай)
+ [5 «хаков» для уменьшения накладных расходов при сборке мусора](#5-хаков-для-уменьшения-накладных-расходов-при-сборке-мусора)
+ [Что такое Heap и Stack память в Java?](#что-такое-heap-и-stack-память-в-java)
+ [Какая разница между Heap и Stack памятью в Java?](#какая-разница-между-heap-и-stack-памятью-в-java)
+ [Расскажите про модель памяти в Java?](#расскажите-про-модель-памяти-в-java)
+ [Как работает сборщик мусора в Java?](#как-работает-сборщик-мусора-в-java)
+ [Расскажите о различных сборщиках мусора?](#расскажите-о-различных-сборщиках-мусора)
+ [Что вы знаете о OutOfMemoryError?](#что-вы-знаете-о-outofmemoryerror)

## Что произойдет со сборщиком мусора, если во время выполнения метода finalize некоторого объекта произойдет исключение?
Во время старта JVM запускается поток nalizer, который работает в фоне. Этот поток
имеет метод runFinalizer, который игнорирует все исключения методов finalize
объектов перед сборкой мусора.
То есть если во время выполнения метода nalize возникнет исключительная
ситуация, его выполнение будет остановлено и это никак не скажется на
работоспособности самого сборщика мусора (garbage collector).

[к оглавлению](#модель-памяти-java)

## Типы ссылок в Java?
1. Сильная ссылка
Это обычная форма создания объектов.
MyObject myObject = new MyObject();
Держатель переменной содержит значительную ссылку на созданный объект. Пока эта переменная активна и сохраняет это значение, экземпляр MyObject не будет собираться сборщиком мусора.
к такому объекту можно получить доступ только посредством прямой ссылки.

2. Слабая ссылка
«Слабые» ссылки также полезны для объектов, которые могут иметь либо продолжительный цикл жизни, либо легко быть созданы заново. Основная идея в том, что если «сборщик мусора» найдет объект, который может быть доступен посредством WeakReference – то он уберет его. Однако заметьте, что может потребоваться несколько запусков «сборщика мусора» прежде чем он обнаружит подобный объект.
WeakReference myObjectRef = new WeakReference(MyObject);
Просто слабая ссылка - это ссылка, которая недостаточно сильна, чтобы заставить объект оставаться в памяти. Слабые ссылки позволяют вам использовать способность сборщика мусора определять доступность для вас, поэтому вам не нужно делать это самостоятельно.
Когда вам нужен созданный объект, просто используйте .get() :
myObjectRef.get();
Следующий код иллюстрирует это:
WeakReference myObjectRef = new WeakReference(MyObject);
System.out.println(myObjectRef.get()); // This will print the object reference address
System.gc();
System.out.println(myObjectRef.get()); // This will print 'null' if the GC cleaned up the object
Объект не может быть доступным через прямую и SoftReference ссылки. К такому объекту можно обратиться лишь посредством WeakReference.
WeakReference<Thing> weakThing = new WeakReference<Thing>(thing);

3. Мягкая ссылка
Мягкие ссылки немного сильнее слабых ссылок. Вы можете создать мягкий ссылочный объект следующим образом:
SoftReference myObjectRef = new SoftReference(MyObject);
Они могут удерживать память сильнее, чем слабая ссылка. Если у вас достаточно ресурсов / ресурсов памяти, сборщик мусора не будет чистить мягкие ссылки с энтузиазмом, как слабые ссылки.
Мягкие ссылки удобны для использования в кешировании. Вы можете создавать объекты с мягкими ссылками в виде кеша, где они сохраняются до тех пор, пока ваша память не закончится. Когда ваша память не может предоставить достаточное количество ресурсов, сборщик мусора удалит мягкие ссылки.
SoftReference myObjectRef = new SoftReference(MyObject);
System.out.println(myObjectRef.get()); // This will print the reference address of the Object
System.gc();
System.out.println(myObjectRef.get()); // This may or may not print the reference address of the Object
К такому объекту нельзя получить доступ через прямую ссылку, он может быть доступен только посредством SoftReference.

4. Ссылка на Phantom
Фантомная ссылка — объект класса java.lang.ref.PhantomReference. Объект, на который существуют только фантомные ссылки, доступен сборщику мусора. В отличие от описанных выше типов ссылок, фантомная ссылка не даёт пользователю возможности «спасти» объект, создав на него сильную ссылку: метод get на ней всегда возвращает null.
Зато с помощью фантомной ссылки можно определить, что объект собирается быть удалён. В силу этих особенностей для фантомная ссылка бесполезна без объекта ReferenceQueue, поэтому для неё определён единственный конструктор:
ReferenceQueue<Wiki> queue = new ReferenceQueue<Wiki>(); //создание очереди 
PhantomReference<Wiki> ref = new PhantomReference<Wiki>(new Wiki("cyclowiki.org"), queue);
Основное предназначение фантомных ссылок — замена методу finalize, имеющему большое количество недостатков.
С их помощью можно реализовать логику подготовки объекта к удалению, например освобождение захваченных им ресурсов, очистка сессии, сохранение состояния или логгирование. Фантомная ссылка, указывающая на удаляемый объект, попадает в ReferenceQueue, откуда она может быть извлечена. Поскольку базовая фантомная ссылка не предоставляет пользователю возможности определить, на какой именно объект она ссылается, стоит реализовывать собственного потомка класса PhantomReference, хранящего идентификатор объекта (не ссылку на сам объект, ибо это будет сильная ссылка — объект перестанет быть доступен сборщику мусора). В таком случае после обращения к идентификатору можно однозначно определить, какой объект был удалён, и выполнить все необходимые операции.

Примечание: объектам, содержащимся в памяти, могут передаваться множественные (SoftReference, WeakReference и PhantomReference) ссылки.

[к оглавлению](#модель-памяти-java)

## Взаимодействие сборщика мусора и ссылок
Каждый раз «сборщик мусора» после запуска произвольно освобождает память, на которую больше нет прямых ссылок. Если же «сборщик мусора» обнаруживает объект, которые могут быть доступны посредством SoftReference , происходит следующее:

Поля объекта, который может быть доступен через SoftReference, устанавливаются в null, что делает данный объект недоступным посредством прямой ссылок.
Данный объект объявляется finalizable.
После того, как был запущен метод finalize()и память, зарезервированная под объект, освобождена – объект помещается в ReferenceQueue, если ReferenceQueue существует.
Если же «сборщик мусора» обнаруживает объект, которые могут быть доступны посредством WeakReference, происходит следующее:

Поля объекта, который может быть доступен через WeakReference, устанавливаются в null, что делает данный объект недоступным посредством прямой ссылки.
Данный объект объявляется finalizable.
После того, как был запущен метод finalize()и память, зарезервированная под объект, освобождена – объект помещается в ReferenceQueue, если он существует.
Если же «сборщик мусора» обнаруживает объект, которые могут быть доступны посредством «фантомной» ссылки, происходит следующее:

Объект доступный посредством «фантомной» ссылки объявляется finalizable.
В отличии от «мягкой» и «слабой» ссылки – фантомная ссылка добавляется к своему ReferenceQueue перед тем как освободится память.(Помните, что все фантомные ссылки должны создаваться с соответствующими ReferenceQueue.) Это дает возможность предпринять какие-то действия до того, как «сборщик мусора» освободит память.

[к оглавлению](#модель-памяти-java)

## Какие переменные не собираются сборщиком мусора?
Глобальные статические до завершения работы программы

[к оглавлению](#модель-памяти-java)

## Когда вызывается finalize()?
Когда сборщик мусора решит уничтожить ваш объект
На самом деле (по крайней мере, в HotSpot 1.6) сборщик мусора не вызывает методы finalize() напрямую, а только добавляет соответствующие объекты в специальный список, вызывая статический метод java.lang.ref.Finalizer.register(Object). Объект класса Finalizer представляет собой ссылку на объект, для которого надо вызвать finalize(), и хранит ссылки на следующий и предыдущий Finalizer, формируя двусвязный список.

Непосредственно вызов finalize() происходит в отдельном потоке «Finalizer» (java.lang.ref.Finalizer.FinalizerThread), который создаётся при запуске виртуальной машины (точнее в статической секции при загрузке класса Finalizer). Методы finalize() вызываются последовательно в том порядке, в котором были добавлены в список сборщиком мусора. Соответственно, если какой-то finalize() зависнет, он подвесит поток «Finalizer», но не сборщик мусора. Это в частности означает, что объекты, не имеющие метода finalize(), будут исправно удаляться, а вот имеющие будут добавляться в очередь, пока не отвиснет поток «Finalizer», не завершится приложение или не кончится память.
[к оглавлению](#модель-памяти-java)

## Для чего на самом деле нужен finalize?
По факту же finalize() определён только в тех дочерних классах, которые работают непосредственно с системными ресурсами (например, FileInputStream)

[к оглавлению](#модель-памяти-java)

## Для чего нужно System.runFinalization()?
Этот вызов создаёт второй поток «SecondaryFinalizer», который так же вызывает finalize() для объектов из той же очереди. При этом поток, вызвавший System.runFinalization() ждёт, пока не кончится очередь Finalizer, которая имеется на данный момент. В принципе, он может вас спасти от OutOfMemory, если основной Finalizer завис. 

[к оглавлению](#модель-памяти-java)

## Приведите пример совместной работы finalize и weak references?
Есть особый сценарий использования, когда вы имеете объекты, связанные через WeakReference/SoftReference. Скажем, объект, достающий информацию из какого-то большого файла (так что весь файл загрузить и закрыть его нельзя). Объект держит файл открытым, чтобы при запросах быстро спозиционироваться и достать нужную запись, но при этом при нехватке памяти вы не возражаете, если он будет уничтожен (но файл надо закрыть). При следующем обращении к файлу вы просто снова создадите такой объект. Если отказаться от finalize(), с такого рода объектами жизнь станет сложнее: придётся отслеживать ReferenceQueue, возиться с фантомными ссылками и т. д.

[к оглавлению](#модель-памяти-java)

## Расскажите об особенностях метода finalize
Так как метод finalize вызывается при первой сборке мусора следующей за моментом когда ваш объект стал недостижим, то вполне реально, что он не будет вызван вообще, ведь ваше приложение может закончить свою работу так и не дойдя до этой самой сборки мусора. Хотя, конечно, есть один замечательный метод System.runFinalizersOnExit(true), вызвав который на старте программы, метод finalize все таки сработает у уже недостижимых объектах во время корректной остановки приложения.
Спецификация JVM не определяет вопрос многопоточности метода финализации. В HotSpot все методы finalize будут вызываться последовательно в одном потоке Finalizer. Однако, если вы вызовете метод System.runFinalization(), то родится еще один поток, который заблокирует текущий и будет выполнять методы finalize, если подходящие объекты есть в очереди. Причем это вполне может происходить параллельно основному потоку Finalizer.
Переопределение метода finalize значительно удлиняет время жизни объекта после смерти, так как он будет удален из памяти не раньше второй сборки мусора. А учитывая два первых пункта, если метод finalize у вас будет тяжелым и\или таких объектов будет очень много, то объекты могут довольно долго висеть в фазе финализации и продолжать занимать место в памяти.
Во время выполнения метода finalize вы можете восстановить ссылку на объект, например, поместив ее в какой-нибудь статический контекст, тем самым вы воскресите объект. Опасность такого маневра заключается в том, что второй раз метод finalize у данного объекта уже никогда вызван не будет. Поэтому если вам по каким-то причинам очень надо воскресить данный объект, то лучше создавайте внутри метода finalize его копию.
Одна из самых неприятных проблем возникающих при использовании метода finalize — это реордеринг. Представьте, что у вас есть два объекта с переопределенным методом finalize, один из которых ссылается на другой. Так вот, если эти объекты стали недостижимы, то порядок вызова методов финализации произойдет в случайном порядке. Таким образом, у вас будет потенциальная опасность вызвать какой-нибудь метод на уже финализированном объекте из метода finalize другого объекта и получить ошибку. Причем проблема будет возникать не на каждом объекте, что добавит головной боли при отладке.
Согласно Джошуа Блоху, автору знаменитой книги «Effective Java: Programming Language Guide», для объектов с переопределенным методом finalize аллокация и сборка может происходить в 430 раз медленнее, чем у обычного объекта.
Любые исключения выброшенные в теле метода будут проигнорированы.
Надо не забыть в конце метода вызвать super.finalize (). А учитывая предыдущий пункт, сделать это необходимо в блоке finally.

[к оглавлению](#модель-памяти-java)

## Расскажите прием уменьшения пауз GC
Разбиение приложения на несколько частей, которые будут запускаться в разных JVM или выделение памяти вне Heap

[к оглавлению](#модель-памяти-java)

## Принятый способ использования finalize при работе со стандартными объектами, например, файлами?
try-with-resourses

[к оглавлению](#модель-памяти-java)

## Пригодность для запуска сборщика мусора (общий случай)
Объект подлежит утилизации, когда он недоступен живому потоку.
Объект может подлежать утилизации в разных случаях:
Если переменная ссылочного типа, которая ссылается на объект, установлена в положение "null", объект подлежит утилизации, в том случае, если на него нет других ссылок.
Если переменная ссылочного типа, которая ссылается на объект, создана для ссылки на другой объект, объект подлежит утилизации, в том случае, если на него нет других ссылок.
Объекты, созданные локально в методе, подлежат утилизации, когда метод завершает работу, если только они не экспортируются из этого метода (т.е, возвращаются или генерируются как исключение).
Объекты, которые ссылаются друг на друга, могут подлежать утилизации, если ни один из них не доступен живому потоку.

[к оглавлению](#модель-памяти-java)

## 5 «хаков» для уменьшения накладных расходов при сборке мусора
1. Избегайте неявного использования строк - Решение: одним из путей может быть явное создание StringBuilder.
Строки являются неотъемлемой частью практически любой структуры данных. Будучи более требовательными к ресурсам, чем другие примитивные типы, они имеют большее влияние на потребление памяти.
Не стоит забывать, что строки иммутабельны. Они не модифицируются после аллокации. Операторы, такие как "+" при объединении строк в действительности создают новый объект String, содержащий конкатенацию строк. Ко всему прочему, это приводит к неявному созданию объекта StringBuilder, который и проводит саму операцию объединения. 

2. Задавайте начальную вместимость списков - Решение: указать начальную емкость везде, где это возможно:
Динамически расширяемые коллекции, такие как ArrayList одни из основных структур, предназначенных для содержания данных переменной длины. ArrayList и другие коллекции, например, HashMap, TreeMap реализованы с использованием нижележащего массива Object[]. Так же как строки (которые являются надстройками над массивами символов), размер массива неизменен. Очевидный вопрос — как получается добавлять элементы в коллекцию, при иммутабельном размере нижележащего массива? Ответ не менее очевиден — выделением больших массивов.

3. Используйте эффективные коллекции примитивных типов
Текущие версии компиляторов Java поддерживают обычные и ассоциативные массивы с ключами и значениями примитивных типов посредством использования «автобоксинга» — оборачивания примитивного значения стандартным объектом, который может быть выделен и удален GC.
Это может иметь некоторые негативные последствия. В Java большая часть коллекций реализуется с использованием внутренних массивов. Каждая пара ключ-значение добавленная в HashMap вызывает выделение внутреннего объекта для хранения обоих значений. Это неизбежное зло сопутствует использованию ассоциативных массивов — каждый раз когда в map добавляется элемент, это приводит к аллокации нового объекта и, возможно, сборке старого. Существует и расходы, связанные с превышением вместимости, т.е. перевыделение ресурсов под новый внутренний массив. Когда мы имеем дело с большим ассоциативным массивом, с тысячами а то и больше объектов, эти внутренние аллокации могут существенно повлиять на GC.
Частый случай — сохранить какое-либо отображение между примитивными типами (например, идентификатор) и объектом. Так как HashMap предназначена для хранения объектных типов, это значит, что каждая вставка подразумевает создание еще одного объекта для «упаковки» значения примитивного типа.
Стандартный метод Integer.valueOf() кэширует значения между -128 и 127, но любое число вне данного диапазона приведет к выделению отдельного объекта для каждой пары ключ-значение. Это приводит к тройному GC overhead в каждом ассоциативном массиве. Для тех, кто прибыл из С++, это может стать новостью — благодаря шаблонам в STL эта проблема решена довольно эффективно.
К счастью, над этим работают в новых версиях Java. Ну а пока попробуем как-то повысить эффективность с помощью замечательных сторонних библиотек, предоставляющих деревья примитивных типов, ассоциативные массивы и списки. Я настоятельно рекомендую Trove, с которым проработал довольно много времени и могу подтвердить реальное уменьшение накладных расходов на сборку мусора в критичном коде.

4. Используйте Stream'ы вместо буферов в памяти
Большинство данных, которыми мы оперируем в серверных приложениях, приходят к нам в виде файлов или потоков данных из сетевых подключений или баз данных. В большинстве случаев, входящие данные приходят в сериализованном виде и требуют десериализацию в объекты перед проведением операций над ними. Этот этап подвержен неявному расходованию памяти, часто в немалых объемах.
Обычно чтение данных в память производится с использованием ByteArrayInputStream, ByteBuffe, затем результат передается на десериализацию.
Это может быть плохим подходом, т.к. вы должны сперва выделить, а затем освободить место под данные, но лишь по окончании построения объектов из них. Но как правило размер данных не известен, что приведет, как вы уже догадались, к постоянному перевыделению памяти под массивы byte[], которые будут расти при превышении вместимости буфера.
Решение крайне просто. Многие библиотеки, такие как нативный сериализатор Java, Protocol Buffers и т.д. способны строить десериализованные объекты, используя данные напрямую из сетевого потока, т.е. не требуют хранения данных в памяти и внутренних массивах. По возможности используйте этот подход — GC скажет спасибо.

5. Иммутабельность не всегда благо
Иммутабельность — это превосходная вещь, но в случае высокопроизводительных вычислений может стать серьезным недостатком. Рассмотрим сценарий передачи между методами списочного объекта.
В случае возврата коллекции из функции, то обычно рекомендуется создать объект коллекции (например, ArrayList) внутри метода, заполнить его и возвратить в форме иммутабельного интерфейса Collection.
Но в некоторых случаях это неприемлемо. Например, в случае когда коллекции, возвращенные из методов, собираются в окончательную коллекцию. Хотя иммутабельность предоставляет прозрачность, в ситуации высоконагруженного сервиса это может означать массивное выделение памяти под промежуточные коллекции.
Решение в этом случае заключается в избегании возврата новых коллекций из методов, вместо этого передавать объект результирующей коллекции как параметр метода.

## Что такое Heap и Stack память в Java?
Java Heap (куча) - динамически распредляемая область памяти, создаваемая при
старте JVM. Используется Java Runtime для выделения памяти под объекты и JRE
классы. Создание нового объекта также происходит в куче. Здесь работает сборщик
мусора: освобождает память путем удаления объектов, на которые нет каких-либо
ссылок. Любой объект, созданный в куче, имеет глобальный доступ и на него могут
ссылаться с любой части приложения.
Cтрогими тезами:
Все обьекты обитают в куче и попадают туда при создании.
обьект состоит из полей класса и методов.
в куче выделяется место под сам обьект, количество выделенной памяти зависит от
полей, если у тебя полем класса, к примеру, служит интовая переменная, то не
важно, инициализируешь ты ее как "0" или как "1000000" - обьект займет в куче свои
биты, + столько байт сколько вмещает тип int(+32 бита), и так с каждым полем.
Стековая память в Java работает по схеме LIFO (Последний-зашел-Первый-вышел).
Всякий раз, когда вызывается метод, в памяти стека создается новый блок, который
содержит примитивы и ссылки на другие объекты в методе расположение в RAM и
достижение процессору через указатель стека. Как только метод заканчивает работу,
блок также перестает использоваться, тем самым предоставляя доступ для следующего
метода. Размер стековой памяти намного меньше объема памяти в куче.
Cтрогими тезами:
Все методы обитают в стеке и попадают туда при вызове.
Переменные в методах так же имеют стековую память, по скольку они локальные.
Если в методе создается обьект, то он помещается в кучу, но его ссылка все еще
будет находится в стеке и после того как метод покинет стек - обьект станет жертвой
сборщика мусора, так как ссылка на него утеряна, и из главного стека программы
невозможно будет добраться до такого обьекта

[к оглавлению](#модель-памяти-java)

## Какая разница между Heap и Stack памятью в Java?
Приведем следующие различия между Heap и Stack памятью в Java.
Куча используется всеми частями приложения в то время как стек используется
только одним потоком исполнения программы.
Всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека
содержится ссылка на него. Память стека содержит только локальные переменные
примитивных типов и ссылки на объекты в куче.
Объекты в куче доступны с любой точки программы, в то время как стековая память
не может быть доступна для других потоков.
Управление памятью в стеке осуществляется по схеме LIFO.
Стековая память существует лишь какое-то время работы программы, а память в
куче живет с самого начала до конца работы программы.
Мы можем использовать -Xms и -Xmx опции JVM, чтобы определить начальный и
максимальный размер памяти в куче. Для стека определить размер памяти можно с
помощью опции -Xss .
Если память стека полностью занята, то Java Runtime бросает
java.lang.StackOverowError, а если память кучи заполнена, то бросается
исключение java.lang.OutOfMemoryError: Java Heap Space.
Размер памяти стека намного меньше памяти в куче. Из-за простоты распределения
памяти (LIFO), стековая память работает намного быстрее кучи.

[к оглавлению](#модель-памяти-java)

## Расскажите про модель памяти в Java?
В Джаве память устроена следующим  образом, есть два вида:
 - Куча
 - Стек
Куча  состоит из статического контекста  и самой кучи
Перейдем  к куче. Куча состоит из двух частей:
 - Новая куча
 - Старая куча
Новая куча в свою очередь состоит из двух частей:
 - Eden(назовем ее первая) куча
 - Survival(выжившая) куча
Краткое описание:
Eden Space (heap) - в этой области выделятся память под все создаваемые из
программы объекты. Большая часть объектов живет недолго (итераторы, временные
объекты, используемые внутри методов и т.п.), и удаляются при выполнении сборок
мусора это области памяти, не перемещаются в другие области памяти. Когда данная
область заполняется (т.е. количество выделенной памяти в этой области превышает
некоторый заданный процент), GC выполняет быструю (minor collection) сборку
мусора. По сравнению с полной сборкой мусора она занимает мало времени, и
затрагивает только эту область памяти - очищает от устаревших объектов Eden
Space и перемещает выжившие объекты в следующую область.
Survivor Space (heap) – сюда перемещаются объекты из предыдущей, после того, как
они пережили хотя бы одну сборку мусора. Время от времени долгоживущие
объекты из этой области перемещаются в Tenured Space.
Tenured (Old) Generation (heap) - Здесь скапливаются долгоживущие объекты
(крупные высокоуровневые объекты, синглтоны, менеджеры ресурсов и проч.).
Когда заполняется эта область, выполняется полная сборка мусора (full, major
collection), которая обрабатывает все созданные JVM объекты.
Permanent Generation (non-heap) - Здесь хранится метаинформация, используемая
JVM (используемые классы, методы и т.п.).

[к оглавлению](#модель-памяти-java)

## Как работает сборщик мусора в Java?
Во-первых что стоит сказать, что у сборщика мусора есть несколько алгоритмов
работы, он не один.
Когда происходит очистка памяти? Если память в Первой куче полностью заполнена,
то туда идет сборщик мусора и делает свою работу) Какую именно, зависит от
обстоятельств… Например если в первой кучи много мусора(т.е. объектов с нулевой
ссылкой), то сборщик мусора помечает эти объекты, далее те что остались объекты со
ссылками он их переносит в Выжившую кучу, а в первой куче он просто все удаляет.
Ситуация другая, в первой кучи мало мусора, но очень много рабочих объектов. Как
поступает в этом случае сборщик  мусора?
Он  помечает мусор, удаляет его и  оставшиеся объекты компонует.
Также следует заметить что при нехватке места в Выжившей куче, объекты
переносятся в старую кучу, там  хранятся как правило долго живущие объекты.
Также следует заметить что сборщик мусора вызывается сам периодически, а не
только когда памяти не хватает.

[к оглавлению](#модель-памяти-java)

## Расскажите о различных сборщиках мусора?
1. Serial (последовательный) — самый простой вариант для приложений с небольшим объемом данных и не требовательных к задержкам. Редко когда используется, но на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию.
2. Parallel (параллельный) — наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности.
3. Concurrent Mark Sweep (CMS) — нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора параллельно с основными потоками приложения. Подходит для работы с относительно большими объемами данных в памяти.
4. Garbage-First (G1) — создан для постепенной замены CMS, особенно в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных.

[к оглавлению](#модель-памяти-java)

## Что вы знаете о OutOfMemoryError?
OutOfMemoryError выбрасывается, когда виртуальная машина Java не может выделить (разместить) объект из-за нехватки памяти, а сборщик мусора не может высвободить ещё.

Область памяти, занимаемая java процессом, состоит из нескольких частей. Тип OutOfMemoryError зависит от того, в какой из них не хватило места.
Области памяти

1. java.lang.OutOfMemoryError: Java heap space
Не хватает места в куче, а именно, в области памяти в которую помещаются объекты, создаваемые программно в вашем приложении. Размер задается параметрами -Xms и -Xmx. Если вы пытаетесь создать объект, а места в куче не осталось, то получаете эту ошибку. Обычно проблема кроется в утечке памяти, коих бывает великое множество, и интернет просто пестрит статьями на эту тему.

2. java.lang.OutOfMemoryError: PermGen space
Данная ошибка возникает при нехватке места в Permanent области, размер которой задается параметрами -XX:PermSize и -XX:MaxPermSize.

3. java.lang.OutOfMemoryError: GC overhead limit exceeded
Данная ошибка может возникнуть как при переполнении первой, так и второй областей. Связана она с тем, что памяти осталось мало и GC постоянно работает, пытаясь высвободить немного места. Данную ошибку можно отключить с помощью параметра -XX:-UseGCOverheadLimit, но, конечно же, её надо не отключать, а либо решать проблему утечки памяти, либо выделять больше объема, либо менять настройки GC.

4. java.lang.OutOfMemoryError: unable to create new native thread
Выбрасывается, когда нет возможности создать еще потоки.

[к оглавлению](#модель-памяти-java)

[Вопросы для собеседования](README.md)
