[Вопросы для собеседования](README.md)

# Git
+ [Что такое Git?](#что-такое-git)
+ [Что такое ветвь в Git?](#что-такое-ветвь-в-git)
+ [Приведите примеры основных команд в Git](#приведите-примеры-основных-команд-в-git)
+ [Как в Git можно влить изменения?](#как-в-git-можно-влить-изменения)
+ [Опишите Git flow](#опишите-git-flow)
+ [Как происходит клонирование репозитория?](#как-происходит-клонирование-репозитория)
+ [Создание, удаление веток, переход на ветки](#создание-удаление-веток-переход-на-ветки)
+ [Назначение файла .gitignore](#назначение-файла-gitignore)
+ [Как отменить коммит?](#как-отменить-коммит)
+ [Зачем нужна команда git rebase?](#зачем-нужна-команда-git-rebase)
+ [Какая разница между Git и SVN?](#какая-разница-между-git-и-svn)


## Что такое Git?
Система контроля версий с открытым исходным кодом, работающая по протоколу Git. 
Преимущества Git:
 - Основывается на слепках
 - Позволяет вести работу на локальном компьютере без подключения к сети (все изменения при этом применяются при подключении)/
 - Низкая стоимость ветвления

[к оглавлению](#git)

## Что такое ветвь в Git?
Легко перемещаемый указатель на коммит. Каждая ветвь - это линия развития кода

[к оглавлению](#git)

## Приведите примеры основных команд в Git
git clone - клонирование репозитория
git add - добавляет содержимое рабочей директории в индекс (staging area) для последующего коммита.
git status - показывает состояния файлов в рабочей директории и индексе: какие файлы изменены, но не добавлены в индекс; какие ожидают коммита в индексе.
git diff  - показывает разницу между любыми двумя Git деревьями.
git log - показывает историю изменений
git fetch - забирает изменения из репозитория
git pull - забирает изменения из удаленного репозитория и автоматически их мерджит
git push - отправляет коммит в репозиторий
git commit - берёт все данные, добавленные в индекс с помощью git add, и сохраняет их слепок во внутренней базе данных, а затем сдвигает указатель текущей ветки на этот слепок.
git amend - дописывает изменения в локальный коммит
git checkout -b a  - переключается на существующую ветку a  в репозитории
git branch a - создает ветку a
git merge a - мерджит ветку a в текущую ветку
git cherry-pick - забираются отдельные коммиты в указанную ветку
git show hash - показывает изменения кода в коммите с хешем has
git reset --hard hash - откатывает ветку к состоянию на момент коммита с хешем hash, включая его
git revert - отменяет изменения
git reset - отменяет изменения
git rm  - удаляет файлы из индекса и рабочей директории
git clean - очищает рабочую директорию от мусора (например, результатов сборки проекта или файлов конфликтов слияний)
git stash - прячет изменения кода
git stash apply - применяет спрятанные изменения
git stash list - выводит список всех ваших прятаний

[к оглавлению](#git)

## Как в Git можно влить изменения?
rebase - используется для очистки истории от “мусорных” веток при локальных коммитах
merge - вливаемая ветка остается отдельной, коммиты добавляются во вливаемую ветку
cherry-pick - забираются отдельные коммиты в указанную ветку

[к оглавлению](#git)

## Опишите Git flow
Вариант Гитхаба:
Master - всегда рабочая ветка
Ветки разработки ответвляются от master
Для вливания кода в мастер ветку используются пулл-реквесты с подтверждением работоспособности кода после прохождения тестов в CI

Расширенный вариант:
Master - всегда рабочая ветка, основа для релизов
Develop - главная ветка разработки, на ней постоянно проходят интеграционные проверки в CI
Ветки разработки ответвляются от develop
Для вливания кода в ветку разработки используются пулл-реквесты с подтверждением работоспособности кода после прохождения тестов в CI
Есть 3 дополнительные типа ветвей:
Feature - разработка по конкретной задаче
Hotfix - быстрый патч, который должен быть доставлен в главную ветвь немедленно (отпочковывается от master и вливается в master)
Release - релизная ветка (после того, как готова, вливается в master с релизным тегом)

[к оглавлению](#git)

## Как происходит клонирование репозитория?
Команда git clone
На самом деле git clone работает как обёртка над некоторыми другими командами. Она создаёт новую директорию, переходит внутрь 
и выполняет git init для создания пустого репозитория, затем она добавляет новый удалённый репозиторий (git remote add) для 
указанного URL (по умолчанию он получит имя origin), выполняет git fetch для этого репозитория и, наконец, обновляет вашу рабочую 
директорию до последнего коммита, используя git checkout.

[к оглавлению](#git)

## Создание, удаление веток, переход на ветки
`git branch a` - создаст ветку а 

`git checkout a` - перейдет на ветку а

`git checkout -b a` - создаст ветку а и перейдет на нее

`git branch -d a` - удалит ветку а

[к оглавлению](#git)

## Назначение файла .gitignore
Инструкция для git по игнорированию файлов (обычно сгенеированных IDE). Можно добавлять правила на включение и исключение файлов заданного типа

[к оглавлению](#git)

## Как отменить коммит?
`git revert hash` - отменит коммит `hash`

[к оглавлению](#git)

## Зачем нужна команда git rebase?
Делает историю коммитов более линейной

[к оглавлению](#git)

## Какая разница между Git и SVN?
GIT распределяется, а SVN - нет. Другими словами, если есть несколько разработчиков работающих с репозиторием у каждого на локальной машине 
будет ПОЛНАЯ копия этого репозитория. Разумеется есть и где-то и центральная машина, с которой можно клонировать репозиторий. Это напоминает SVN. 
Основной плюс в том, что если вдруг у вас нет доступа к интернету, сохраняется возможность работать с репозиторием. Потом только один раз сделать 
синхронизацию и все остальные разработчики получат поолную историю.
GIT сохраняет метаданные изменений, а SVN целые файлы. Это экономит место и время.

[к оглавлению](#git)


[Вопросы для собеседования](README.md)
