[Список всех вопросов по «Spring Framework»](spring.md)

# Spring AOP
+ [Что такое _«Spring AOP»_?](#что-такое-spring-aop)
+ [Что такое `aspect`, `advice`, `pointcut`, `advice argiments` в _«Spring AOP»_?](#что-такое-aspect-advice-pointcut-advice-argiments-в-spring-aop)
+ [Какие есть типы `Weaving`? Какие поддерживает `Spring AOP`?](#какие-есть-типы-weaving-какие-поддерживает-spring-aop)
+ [В чем разница между `Spring AOP` и `AspectJ`?](#в-чем-разница-между-spring-aop-и-aspectj)
+ [Какие есть типы `Advice`?](#какие-есть-типы-advice)
+ [В чем разница между _«Сквозной Функциональностью (Cross Cutting Concerns)»_ и _«Spring AOP»_?](#в-чем-разница-между-сквозной-Функциональностью-cross-cutting-concerns-и-spring-aop)
+ [Почему возвращаемое значение при применении аспекта `@Around` может потеряться? Назовите причины.](#почему-возвращаемое-значение-при-применении-аспекта-around-может-потеряться-назовите-причины)
+ [В чем разница между `Filters`, `Listeners` and `Interceptors`?](#в-чем-разница-между-filters-listeners-and-interceptors)
## Что такое _«Spring AOP»_?

__Аспектно-ориентированное программирование__ (`AOP`) - парадигма
программирования, основанная на идее разделения функциональности для улучшения
разбиения программы на модули. `AOP` и `Spring` - взаимодополняющие технологии,
которые позволяют решать сложные проблемы путем разделения функционала на
отдельные модули. `AOP` предоставляет возможность реализации сквозной логики -
т.е. логики, которая применяется к множеству частей приложения - в одном месте и
обеспечения автоматического применения этой логики по всему приложению. Подход
`Spring` к `AOP` заключается в создании ""динамических прокси"" для целевых объектов и
""привязывании"" объектов к конфигурированному совету для выполнения сквозной
логики.

[к оглавлению](#spring-aop)

## Что такое `aspect`, `advice`, `pointcut`, `advice argiments` в _«Spring AOP»_?

Основные понятия `AOP`:
+ _Аспект_ (англ. `aspect`) - модуль или класс, реализующий сквозную
функциональность. Аспект изменяет поведение остального кода, применяя _совет_ в
точках соединения, определённых некоторым срезом.
+ _Совет_ (англ. `advice`) - фрагмент кода, который должен выполняться в отдельной
точке соединения. Существует несколько типов советов, совет может быть выполнен
до, после или вместо точки соединения.
+ _Точка соединения_ (англ. `joinpoint`) - это четко определенная точка в выполняемой
программе, где следует применить совет. Типовые примеры точек соединения
включают обращение к методу, собственно `Method Invocation`, инициализацию
класса и создание экземпляра объекта. Многие реализации `AOP` позволяют
использовать вызовы методов и обращения к полям объекта в качестве точек
соединения.
+ _Срез_ (англ. `pointcut`) - набор точек соединения. Срез определяет, подходит ли
данная точка соединения к данному совету. Самые удобные реализации `AOP`
используют для определения срезов синтаксис основного языка (например, в `AspectJ`
применяются Java-сигнатуры) и позволяют их повторное использование с помощью
переименования и комбинирования.
+ _Связывание_ (англ. `weaving`) представляет собой процесс действительной вставки
аспектов в определенную точку кода приложения. Для решений `AOP` времени
компиляции это делается на этапе компиляции, обычно в виде дополнительного
шага процесса сборки. Аналогично, для решений `AOP` времени выполнения
связывание происходит динамически во время выполнения. В AspectJ
поддерживается еще один механизм связывания под названием связывание во время
загрузки (load-time weaving - LTW), который перехватывает лежащий в основе
загрузчик классов JVM и обеспечивает связывание с байт-кодом, когда он
загружается загрузчиком классов.
+ _Цель_ (англ. `target`) - это объект, поток выполнения которого изменяется каким-то
процессом АОП. На целевой объект часто ссылаются как на объект, снабженный
советом.
+ _Внедрение_ (англ. `introduction`) - представляет собой процесс,
посредством которого можно изменить структуру объекта за счет введения в него
дополнительных методов или полей, изменение иерархии наследования для
добавления функциональности аспекта в инородный код. Обычно реализуется с
помощью некоторого метаобъектного протокола (англ. `metaobject protocol`, `MOP`).

[к оглавлению](#spring-aop)

## Какие есть типы `Weaving`? Какие поддерживает `Spring AOP`?

И `AspectJ`, и `Spring AOP` используют разные типы `weaving`, которые влияют на их поведение в отношении производительности и простоты использования.

`AspectJ` использует три различных типа `weaving`:

+ __Compile-time weaving__: компилятор `AspectJ` принимает в качестве входных данных как исходный код нашего аспекта, так и нашего приложения, а в качестве выходных данных создает `weaving` файлы классов.
+ __Post-compile weaving__: это также известно как бинарное плетение. Он используется для объединения существующих файлов классов и файлов JAR с нашими аспектами
+ __Load-time weaving__: это точно так же, как и в предыдущем двоичном плетении, с той разницей, что `weaving` откладывается до тех пор, пока загрузчик классов не загрузит файлы классов в JVM

Поскольку `AspectJ` использует `weaving` времени компиляции и загрузки классов, `Spring AOP` использует `weaving` времени выполнения .

[к оглавлению](#spring-aop)

## В чем разница между `Spring AOP` и `AspectJ`?

`AspectJ` де-факто является стандартом реализации АОП. Реализация АОП от `Spring` имеет некоторые отличия:

+ `Spring AOP` немного проще, т.к. нет необходимости следить за процессом связывания.
+ `Spring AOP` поддерживает аннотации `AspectJ`, таким образом мы можем работать в спринг проекте похожим образом с `AspectJ` проектом.
+ `Spring AOP` поддерживает только `proxy-based` АОП и может использовать только один тип точек соединения — `Method Invocation`. `AspectJ` поддерживает все виды точек соединения.
+ Недостатком `Spring AOP` является работа только со своими бинами, которые существуют в `Spring Context`.

[к оглавлению](#spring-aop)

## Какие есть типы `Advice`?

Есть несколько типов `advice`:

+ действие до вызова метода `@Before`;
+ действие после вызова метода `@After` (выполняется независимо от того, нормально ли завершился метод или было выброшено исключение);
+ действие после вызова метода `@AfterReturing` (выполняется при нориальном завершении метода);
+ действие после вызова метода `@AfterThrowing` (выполняется, если  было выброшено исключение);
+ действие и до, и после `@Around`.

[к оглавлению](#spring-aop)

## В чем разница между _«Сквозной Функциональностью (Cross Cutting Concerns)»_ и _«Spring AOP»_?

__Сквозная Функциональность__ — функциональность, которая может потребоваться вам на нескольких различных уровнях — логирование, 
управление производительностью, безопасность и т.д.

АОП — один из подходов к реализации данной проблемы

[к оглавлению](#spring-aop)

## Почему возвращаемое значение при применении аспекта `@Around` может потеряться? Назовите причины.

Метод, помеченный аннотацией `@Around`, должен возвращать значение, которое он (метод) получил из _joinpoint.proceed()_:
```java
@Around(""trackTimeAnnotation()"")
public Object around(ProceedingJoinPoint joinPoint) throws Throwable{
    long startTime = System.currentTimeMillis();
    Object retVal = joinPoint.proceed();
    long timeTaken = System.currentTimeMillis() - startTime;
    logger.info(""Time taken by {} is equal to {}"",joinPoint, timeTaken);
    return retVal;
}
```

[к оглавлению](#spring-aop)

## В чем разница между `Filters`, `Listeners` and `Interceptors`?

Концептуально всё просто, фильтры сервлетов могут перехватывать только `HTTPServlets`. `Listeners` могут перехватывать специфические события. 

Фильтры и перехватчики делают по сути одно и тоже: они перехватывают какое-то событие, и делают что-то до или после.
Java EE использует термин `Filter`, `Spring` называет их `Interceptors`.

Именно здесь `AOP` используется в полную силу, благодаря чему возможно перехватывание вызовов любых объектов.

[к оглавлению](#spring-aop)