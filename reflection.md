[Вопросы для собеседования](README.md)

# Рефлексия
+ [Что такое рефлексия?](#что-такое-рефлексия)
+ [Может ли объект получить доступ к private-переменным класса? Если да, то каким образом?](#может-ли-объект-получить-доступ-к-private-переменным-класса-если-да-то-каким-образом)
+ [В чем отличия интроспекции и рефлексии?](#в-чем-отличия-интроспекции-и-рефлексии)
+ [Приведите несколько примеров, когда рефлексия может помочь?](#приведите-несколько-примеров-когда-рефлексия-может-помочь)
+ [Определение свойств класса в режиме runtime](#определение-свойств-класса-в-режиме-runtime)
+ [Определение интерфейсов и конструкторов класса в режиме runtime](#определение-интерфейсов-и-конструкторов-класса-в-режиме-runtime)
+ [Определение полей и методов класса в режиме runtime](#определение-полей-и-методов-класса-в-режиме-runtime)
+ [Исследование, получение и установка значений полей класса.](#исследование-получение-и-установка-значений-полей-класса)

## Что такое рефлексия?
Java Reflection API - это механизм получения информации в режиме run-time приложения. Рефлексия позволяет получать информацию о конструкторах, методах и полях классов, и выполнять следующие операции над полями и методами класса :

 - определение класса объекта;
 - получение информации о полях, методах, конструкторах и суперклассах;
 - получение информации о модификаторах полей и методов;
 - создание экземпляра класса, имя которого неизвестно до момента выполнения программы;
 - определение и изменение значений свойств объекта;
 - вызов метода объекта.
Интерфейс Java Reflection API состоит из классов пакетов java.lang и java.lang.reflect.

[к оглавлению](#рефлексия)

## Может ли объект получить доступ к private-переменным класса? Если да, то каким образом?
```java 
B b = new B();
Class clazz = B.class;
Field iField = clazz.getDeclaredField("i");
iField.setAccessible(true);
int fieldValue = iField.getInt(b);
System.out.println("i = " + fieldValue);
```

[к оглавлению](#рефлексия)

## В чем отличия интроспекции и рефлексии?
Интроспекция позволяет вам изучать атрибуты объекта во время выполнения программы, а рефлексия — манипулировать ими. Рефлексия — это способность компьютерной программы изучать и модифицировать свою структуру и поведение (значения, мета-данные, свойства и функции) во время выполнения. Простым языком: она позволяет вам вызывать методы объектов, создавать новые объекты, модифицировать их, даже не зная имён интерфейсов, полей, методов во время компиляции. Из-за такой природы рефлексии её труднее реализовать в статически типизированных языках, поскольку ошибки типизации возникают во время компиляции, а не исполнения программы (подробнее об этом здесь). Тем не менее, она возможна, ведь такие языки, как Java, C# и другие допускают использование как интроспекции, так и рефлексии (но не C++, он позволяет использовать лишь интроспекцию).
По той же причине рефлексию проще реализовать в интерпретируемых языках, поскольку когда функции, объекты и другие структуры данных создаются и вызываются во время работы программы, используется какая-то система распределения памяти. Интерпретируемые языки обычно предоставляют такую систему по умолчанию, а для компилируемых понадобится дополнительный компилятор и интерпретатор, который следит за корректностью рефлексии.

[к оглавлению](#рефлексия)

## Приведите несколько примеров, когда рефлексия может помочь?
Определить класс объекта. 
Получить информацию о модификаторах класса, полях, методах, конструкторах и суперклассах.
Выяснить, какие константы и методы принадлежат интерфейсу. 
Создать экземпляр класса, имя которого неизвестно до момента выполнения программы.
Получить и установить значение свойства объекта.
Вызвать метод объекта.
Создать новый массив, размер и тип компонентов которого неизвестны до момента выполнения программ.

[к оглавлению](#рефлексия)

## Определение свойств класса в режиме runtime
В работающем приложении для получения класса используется метод forName (String className) :

// Без использования Reflection
Foo foo = new Foo();
 
// С использованием Reflection
Class foo = Class.forName("Foo");
Наименование класса, включающего пакет (package), извлекается методом getName() объекта Class :

Class aclass = foo.getClass(); 
System.out.println (aclass.getName());
Для получения значения модификатора класса используется метод getModifiers(). Класс java.lang.reflect.Modifier содержит статические методы, возвращающие логическое значения проверки модификатора класса :
Для получения суперкласса рефлексированного объекта (класса) необходимо использовать метод getSuperclass () :
Поскольку в Java отсутствет множественное наследование, то для получения всех предков следует рекурсивно вызвать метод getSuperclass () в цикле, пока не будет достигнут Object, являющийся родителем всех классов. Object не имеет родителей, поэтому вызов его метода getSuperclass () вернет null.

[к оглавлению](#рефлексия)

## Определение интерфейсов и конструкторов класса в режиме runtime
Для получения в режиме run-time списка интерфейсов, реализующих классом, необходимо получить Class и использовать его метод getInterfaces(). Следующий пример демонстрирует получение списка интерфейсов класса ArrayList :
``` java
Class<?>   cls = ArrayList.class; 
Class<?>[] ifs = cls.getInterfaces(); 
```

Метод класса getConstructors () позволяет получить массив открытых конструкторов типа java.lang.reflect.Constructor. После этого, можно извлекать информацию о типах параметров конструктора и генерируемых исключениях. Пример :
``` java
Class<?> cls = obj.getClass(); 
Constructor[] constructors = cls.getConstructors(); 
```

[к оглавлению](#рефлексия)

## Определение полей и методов класса в режиме runtime
Метод getFields() объекта Class возвращает массив открытых полей типа java.lang.reflect.Field. Эти поля могут быть определены не только в классе, но также и в его родителях (суперклассе), либо интерфейсах, реализованных классом или его родителями. Класс Field позволяет получить имя поля, тип и модификаторы.
Метод getMethods() объекта Class возвращает массив открытых методов типа java.lang.reflect.Method. Эти методы могут быть определены не только в классе, но также и в его родителях (суперклассе), либо интерфейсах, реализованных классом или его родителями. Класс Method позволяет получить имя метода, тип возвращаемого им значения, типы параметров метода, модификаторы и генерируемые исключения.

[к оглавлению](#рефлексия)

## Исследование, получение и установка значений полей класса.
Методы getField() и getFields() возвращают только открытые члены данных класса. Если требуется получить все поля некоторого класса нужно использовать методы getDeclaredField() и getDeclaredFields(). Эти методы работают точно также как их аналоги getField() и getFields(), за исключением того, что они возвращают все поля, включая закрытые и защищенные. Чтобы получить значение поля, нужно сначала получить для этого поля объект типа Field затем использовать метод get(). Метод принимает входным параметром ссылку на объект класса.
``` java
Class c = obj.getClass(); 
Field field = c.getField("name"); 
String nameValue = (String) field.get(obj) 
Так же у класса Field имеются специализированные методы для получения значений примитивных типов: getInt(), getFloat(), getByte() и др.. Для установки значения поля, используется метод set().
Class c = obj.getClass(); 
Field field = c.getField("name"); 
field.set(obj, "New name"); 
```
[к оглавлению](#рефлексия)


[Вопросы для собеседования](README.md)
