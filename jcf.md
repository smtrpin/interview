[Вопросы для собеседования](README.md)

# Java Collections Framework
+ [Что такое _«коллекция»_?](#что-такое-коллекция)
+ [Назовите основные интерфейсы JCF и их реализации.](#назовите-основные-интерфейсы-jcf-и-их-реализации)
+ [Расположите в виде иерархии следующие интерфейсы: `List`, `Set`, `Map`, `SortedSet`, `SortedMap`, `Collection`, `Iterable`, `Iterator`, `NavigableSet`, `NavigableMap`.](#расположите-в-виде-иерархии-следующие-интерфейсы-list-set-map-sortedset-sortedmap-collection-iterable-iterator-navigableset-navigablemap)
+ [Какие абстрактные классы определяют базовый функционал?](#какие-абстрактные-классы-определяют-базовый-функционал)
+ [Почему `Map` — это не `Collection`, в то время как `List` и `Set` являются `Collection`?](#почему-map--это-не-collection-в-то-время-как-list-и-set-являются-collection)
+ [В чем разница между классами `java.util.Collection` и `java.util.Collections`?](#в-чем-разница-между-классами-javautilcollection-и-javautilcollections)
+ [Какие классы коллекций позволяют получить доступ к любому элементу?](#какие-классы-коллекций-позволяют-получить-доступ-к-любому-элементу)
+ [Что такое "потокобезопасные коллекции"?](#что-такое-потокобезопасные-коллекции)
+ [Что такое «fail-fast поведение»?](#что-такое-fail-fast-поведение)
+ [Какая разница между fail-fast и fail-safe?](#какая-разница-между-fail-fast-и-fail-safe)
+ [Приведите примеры итераторов реализующих поведение fail-safe](#приведите-примеры-итераторов-реализующих-поведение-fail-safe)
+ [Для чего используется интерфейс `Iterator`?](#для-чего-используется-интерфейс-iterator)
+ [Что вы знаете об интерфейсе `Iterable`?](#что-вы-знаете-об-интерфейсе-iterable)
+ [Чем различаются `Enumeration` и `Iterator`.](#чем-различаются-enumeration-и-iterator)
+ [Как между собой связаны `Iterable` и `Iterator`?](#как-между-собой-связаны-iterable-и-iterator)
+ [Как между собой связаны `Iterable`, `Iterator` и «for-each»?](#как-между-собой-связаны-iterable-iterator-и-for-each)
+ [Сравните `Iterator` и `ListIterator`.](#сравните-iterator-и-listiterator)
+ [Что произойдет при вызове `Iterator.next()` без предварительного вызова `Iterator.hasNext()`?](#что-произойдет-при-вызове-iteratornext-без-предварительного-вызова-iteratorhasnext)
+ [Сколько элементов будет пропущено, если `Iterator.next()` будет вызван после 10-ти вызовов `Iterator.hasNext()`?](#сколько-элементов-будет-пропущено-если-iteratornext-будет-вызван-после-10-ти-вызовов-iteratorhasnext)
+ [Почему не существует метода `Iterator.add()` для добавления элементов в коллекцию?](#почему-не-существует-метода-iteratoradd-для-добавления-элементов-в-коллекцию)
+ [Как поведёт себя коллекция, если вызвать `iterator.remove()`?](#как-поведёт-себя-коллекция-если-вызвать-iteratorremove)
+ [Как поведёт себя уже инстанциированный итератор для `collection`, если вызвать `collection.remove()`?](#как-поведёт-себя-уже-инстанциированный-итератор-для-collection-если-вызвать-collectionremove)
+ [Как избежать `ConcurrentModificationException` во время перебора коллекции?](#как-избежать-concurrentmodificationexception-во-время-перебора-коллекции)
+ [Что такое `UnsupportedOperationException`?](#что-такое-unsupportedoperationexception)
+ [Что такое очередь и стэк, перечислите разницу между ними?](#что-такое-очередь-и-стэк-перечислите-разницу-между-ними)
+ [Какая коллекция реализует дисциплину обслуживания FIFO?](#какая-коллекция-реализует-дисциплину-обслуживания-fifo)
+ [Какая коллекция реализует дисциплину обслуживания FILO?](#какая-коллекция-реализует-дисциплину-обслуживания-filo)
+ [Для чего нужен класс `Arrays`?](#для-чего-нужен-класс-arrays)
+ [В чем разница между классами `java.util.Arrays` и `java.lang.reflect.Array`?](#в-чем-разница-между-классами-javautilarrays-и-javalangreflectarray)
+ [Чем отличается `ArrayList` от `Vector`?](#чем-отличается-arraylist-от-vector)
+ [Почему нельзя написать `ArrayList<List> numbers = new ArrayList<ArrayList>();` но можно `List<ArrayList> numbers = new ArrayList<ArrayList>();`?](#почему-нельзя-написать-arraylistlist-numbers-new-arraylistarraylist-но-можно-listarraylist-numbers-new-arraylistarraylist)
+ [Зачем добавили `ArrayList`, если уже был `Vector`?](#зачем-добавили-arraylist-если-уже-был-vector)
+ [Чем отличается `ArrayList` от `LinkedList`? В каких случаях лучше использовать первый, а в каких второй?](#чем-отличается-arraylist-от-linkedlist-В-каких-случаях-лучше-использовать-первый-а-в-каких-второй)
+ [Что работает быстрее `ArrayList` или `LinkedList`?](#что-работает-быстрее-arraylist-или-linkedlist)
+ [Оцените ассимптотическую сложность работы `ArrayList` и `LinkedList`](#оцените-ассимптотическую-сложность-работы-arraylist-и-linkedlist)
+ [Какое худшее время работы метода `contains()` для элемента, который есть в `LinkedList`?](#какое-худшее-время-работы-метода-contains-для-элемента-который-есть-в-linkedlist)
+ [Какое худшее время работы метода `contains()` для элемента, который есть в `ArrayList`?](#какое-худшее-время-работы-метода-contains-для-элемента-который-есть-в-arraylist)
+ [Какое худшее время работы метода `add()` для `LinkedList`?](#какое-худшее-время-работы-метода-add-для-linkedlist)
+ [Какое худшее время работы метода `add()` для `ArrayList`?](#какое-худшее-время-работы-метода-add-для-arraylist)
+ [Необходимо добавить 1 млн. элементов, какую структуру вы используете?](#необходимо-добавить-1-млн-элементов-какую-структуру-вы-используете)
+ [Как происходит удаление элементов из `ArrayList`? Как меняется в этом случае размер `ArrayList`?](#как-происходит-удаление-элементов-из-arraylist-Как-меняется-в-этом-случае-размер-arraylist)
+ [Предложите эффективный алгоритм удаления нескольких рядом стоящих элементов из середины списка, реализуемого `ArrayList`.](#предложите-эффективный-алгоритм-удаления-нескольких-рядом-стоящих-элементов-из-середины-списка-реализуемого-arraylist)
+ [Сколько необходимо дополнительной памяти при вызове `ArrayList.add()`?](#сколько-необходимо-дополнительной-памяти-при-вызове-arraylistadd)
+ [Сколько выделяется дополнительно памяти при вызове `LinkedList.add()`?](#сколько-выделяется-дополнительно-памяти-при-вызове-linkedlistadd)
+ [Оцените количество памяти на хранение одного примитива типа `byte` в `LinkedList`?](#оцените-количество-памяти-на-хранение-одного-примитива-типа-byte-в-linkedlist)
+ [Оцените количество памяти на хранение одного примитива типа `byte` в `ArrayList`?](#оцените-количество-памяти-на-хранение-одного-примитива-типа-byte-в-arraylist)
+ [Для `ArrayList` или для `LinkedList` операция добавления элемента в середину (`list.add(list.size()/2, newElement)`) медленнее?](#для-arraylist-или-для-linkedlist-операция-добавления-элемента-в-середину-listaddlistsize2-newelement-медленнее)
+ [В реализации класса `ArrayList` есть следующие поля: `Object[] elementData`, `int size`. Объясните, зачем хранить отдельно `size`, если всегда можно взять `elementData.length`?](#в-реализации-класса-arraylist-есть-следующие-поля-object-elementdata-int-size-Объясните-зачем-хранить-отдельно-size-если-всегда-можно-взять-elementdatalength)
+ [Сравните интерфейсы `Queue` и `Deque`.](#сравните-интерфейсы-queue-и-deque)
+ [Кто кого расширяет: `Queue` расширяет `Deque`, или `Deque` расширяет `Queue`?](#кто-кого-расширяет-queue-расширяет-deque-или-deque-расширяет-queue)
+ [Расскажите про класс `ArrayDeque`](#расскажите-про-класс-arraydeque)
+ [Что такое `BlockingQueue`?](#что-такое-blockingqueue)
+ [Расскажите про класс `LinkedList`](#расскажите-про-класс-linkedlist)
+ [Почему `LinkedList` реализует и `List`, и `Deque`?](#почему-linkedlist-реализует-и-list-и-deque)
+ [`LinkedList` — это односвязный, двусвязный или четырехсвязный список?](#linkedlist--это-односвязный-двусвязный-или-четырехсвязный-список)
+ [Как перебрать элементы `LinkedList` в обратном порядке, не используя медленный `get(index)`?](#как-перебрать-элементы-linkedlist-в-обратном-порядке-не-используя-медленный-getindex)
+ [Что позволяет сделать `PriorityQueue`?](#что-позволяет-сделать-priorityqueue)
+ [`Stack` считается «устаревшим». Чем его рекомендуют заменять? Почему?](#stack-считается-устаревшим-Чем-его-рекомендуют-заменять-Почему)
+ [Для чего нужен интерфейс `Map`](#для-чего-нужен-интерфейс-map)
+ [Назовите различия между `List` и `Map`?](#назовите-различия-между-list-и-map)
+ [Зачем нужен `HashMap`, если есть `Hashtable`?](#зачем-нужен-hashmap-если-есть-hashtable)
+ [Различия между `HashMap` и `Collection.synchronizedMap(HashMap)`](#различия-между-hashmap-и-collectionsynchronizedmaphashmap)
+ [Различия между `HashTable` и `Collection.synchronized(HashMap)`](#различия-между-hashtable-и-collectionsynchronizedhashmap)
+ [В чем разница между `HashMap` и `IdentityHashMap`? Для чего нужна `IdentityHashMap`?](#в-чем-разница-между-hashmap-и-identityhashmap-Для-чего-нужна-identityhashmap)
+ [В чем разница между `HashMap` и `WeakHashMap`? Для чего используется `WeakHashMap`?](#в-чем-разница-между-hashmap-и-weakhashmap-Для-чего-используется-weakhashmap)
+ [В чем разница между `HashMap` и `ConcurrentHashMap`?](#в-чем-разница-между-hashmap-и-concurrenthashmap)
+ [В `WeakHashMap` используются WeakReferences. А почему бы не создать `SoftHashMap` на SoftReferences?](#в-weakhashmap-используются-weakreferences-А-почему-бы-не-создать-softhashmap-на-softreferences)
+ [В `WeakHashMap` используются WeakReferences. А почему бы не создать `PhantomHashMap` на PhantomReferences?](#в-weakhashmap-используются-weakreferences-А-почему-бы-не-создать-phantomhashmap-на-phantomreferences)
+ [`LinkedHashMap` - что в нем от `LinkedList`, а что от `HashMap`?](#linkedhashmap---что-в-нем-от-linkedlist-а-что-от-hashmap)
+ [Говорят, на `LinkedHashMap` легко сделать простенький кэш c "invalidation policy", знаете как?](#говорят-на-linkedhashmap-легко-сделать-простенький-кэш-c-invalidation-policy-знаете-как)
+ [Какая особенность интерфейса `SortedMap`?](#какая-особенность-интерфейса-sortedmap)
+ [Какая особенность интерфейса `NavigableMap`?](#какая-особенность-интерфейса-navigablemap)
+ [В чем проявляется «сортированность» `SortedMap`, кроме того, что `toString()` выводит все элементы по порядку?](#в-чем-проявляется-сортированность-sortedmap-кроме-того-что-tostring-выводит-все-элементы-по-порядку)
+ [Как устроен `HashMap`?](#как-устроен-hashmap)
+ [Опишите процесс создания ключа для `HashMap`](#опишите-процесс-создания-ключа-для-hashmap)
+ [Влияние случайных/фиксированных значений для значения ключа](#влияние-случайныхфиксированных-значений-для-значения-ключа)
+ [Как устроен `TreeMap`?](#как-устроен-treemap)
+ [Согласно Кнуту и Кормену существует две основных реализации хэш-таблицы: на основе открытой адресации и на основе метода цепочек. Как реализована `HashMap`? Почему, по вашему мнению, была выбрана именно эта реализация? В чем плюсы и минусы каждого подхода?](#согласно-Кнуту-и-Кормену-существует-две-основных-реализации-хэш-таблицы-на-основе-открытой-адресации-и-на-основе-метода-цепочек-Как-реализована-hashmap-Почему-по-вашему-мнению-была-выбрана-именно-эта-реализация-В-чем-плюсы-и-минусы-каждого-подхода)
+ [Как работает `HashMap` при попытке сохранить в него два элемента по ключам с одинаковым `hashCode()`, но для которых `equals() == false`?](#как-работает-hashmap-при-попытке-сохранить-в-него-два-элемента-по-ключам-с-одинаковым-hashcode-но-для-которых-equals--false)
+ [Какое начальное количество корзин в `HashMap`?](#какое-начальное-количество-корзин-в-hashmap)
+ [Какова оценка временной сложности операций над элементами из `HashMap`? Гарантирует ли `HashMap` указанную сложность выборки элемента?](#какова-оценка-временной-сложности-операций-над-элементами-из-hashmap-Гарантирует-ли-hashmap-указанную-сложность-выборки-элемента)
+ [Возможна ли ситуация, когда `HashMap` выродится в список даже с ключами имеющими разные `hashCode()`?](#возможна-ли-ситуация-когда-hashmap-выродится-в-список-даже-с-ключами-имеющими-разные-hashcode)
+ [В каком случае может быть потерян элемент в `HashMap`?](#в-каком-случае-может-быть-потерян-элемент-в-hashmap)
+ [Почему нельзя использовать `byte[]` в качестве ключа в `HashMap`?](#почему-нельзя-использовать-byte-в-качестве-ключа-в-hashmap)
+ [Какова роль `equals()` и `hashCode()` в `HashMap`?](#какова-роль-equals-и-hashcode-в-hashmap)
+ [Каково максимальное число значений `hashCode()`?](#каково-максимальное-число-значений-hashcode)
+ [Какое худшее время работы метода get(key) для ключа, которого нет в `HashMap`?](#какое-худшее-время-работы-метода-getkey-для-ключа-которого-нет-в-hashmap)
+ [Какое худшее время работы метода get(key) для ключа, который есть в `HashMap`?](#какое-худшее-время-работы-метода-getkey-для-ключа-который-есть-в-hashmap)
+ [Сколько переходов происходит в момент вызова `HashMap.get(key)` по ключу, который есть в таблице?](#сколько-переходов-происходит-в-момент-вызова-hashmapgetkey-по-ключу-который-есть-в-таблице)
+ [Сколько создается новых объектов, когда вы добавляете новый элемент в `HashMap`?](#сколько-создается-новых-объектов-когда-вы-добавляете-новый-элемент-в-hashmap)
+ [Как и когда происходит увеличение количества корзин в `HashMap`?](#как-и-когда-происходит-увеличение-количества-корзин-в-hashmap)
+ [Объясните смысл параметров в конструкторе `HashMap(int initialCapacity, float loadFactor)`.](#объясните-смысл-параметров-в-конструкторе-hashmapint-initialcapacity-float-loadfactor)
+ [Будет ли работать `HashMap`, если все добавляемые ключи будут иметь одинаковый `hashCode()`?](#будет-ли-работать-hashmap-если-все-добавляемые-ключи-будут-иметь-одинаковый-hashcode)
+ [Как перебрать все ключи `Map`?](#как-перебрать-все-ключи-map)
+ [Как перебрать все значения `Map`?](#как-перебрать-все-значения-map)
+ [Как перебрать все пары «ключ-значение» в `Map`?](#как-перебрать-все-пары-ключ-значение-в-map)
+ [Интерфейс `Set` и класс `HashSet`](#интерфейс-set-и-класс-hashset)
+ [Назовите отличия между `Set` и `List`](#назовите-отличия-между-set-и-list)
+ [В чем отличия `TreeSet` и `HashSet`?](#в-чем-отличия-treeset-и-hashset)
+ [Что будет, если добавлять элементы в `TreeSet` по возрастанию?](#что-будет-если-добавлять-элементы-в-treeset-по-возрастанию)
+ [Что вы знаете про интерфейс `SortedSet`?](#что-вы-знаете-про-интерфейс-sortedset)
+ [Назовите различия между `TreeSet` и `SortedSet`?](#назовите-различия-между-treeset-и-sortedset)
+ [Что вы знаете про интерфейс `NavigableSet`?](#что-вы-знаете-про-интерфейс-navigableset)
+ [Чем `LinkedHashSet` отличается от `HashSet`?](#чем-linkedhashset-отличается-от-hashset)
+ [Для `Enum` есть специальный класс `java.util.EnumSet`. Зачем? Чем авторов не устраивал `HashSet` или `TreeSet`?](#для-enum-есть-специальный-класс-javautilenumset-Зачем-Чем-авторов-не-устраивал-hashset-или-treeset)
+ [Какие существуют способы перебирать элементы списка?](#какие-существуют-способы-перебирать-элементы-списка)
+ [Расскажите про интерфейс `Comparable`](#расскажите-про-интерфейс-comparable)
+ [Расскажите про интерфейс `Comparator`](#расскажите-про-интерфейс-comparator)
+ [В чем заключаются отличия `java.util.Comparator` от `java.lang.Comparable`?](#в-чем-заключаются-отличия-javautilcomparator-от-javalangcomparable)
+ [Какой алгоритм сортировки используется в методе `Collections.sort()`?](#какой-алгоритм-сортировки-используется-в-методе-collectionssort)
+ [Сортировка по нескольким критериям](#сортировка-по-нескольким-критериям)
+ [Перечислите синхронизированные оболочки](#перечислите-синхронизированные-оболочки)
+ [Перечислите неизменяемые оболочки](#перечислите-неизменяемые-оболочки)
+ [Каким образом можно получить синхронизированные объекты стандартных коллекций?](#каким-образом-можно-получить-синхронизированные-объекты-стандартных-коллекций)
+ [Как получить коллекцию только для чтения?](#как-получить-коллекцию-только-для-чтения)
+ [Как сделать потокобезопасную коллекцию?](#как-сделать-потокобезопасную-коллекцию)
+ [Напишите однопоточную программу, которая заставляет коллекцию выбросить `ConcurrentModificationException`.](#напишите-однопоточную-программу-которая-заставляет-коллекцию-выбросить-concurrentmodificationexception)
+ [Приведите пример, когда какая-либо коллекция выбрасывает `UnsupportedOperationException`.](#приведите-пример-когда-какая-либо-коллекция-выбрасывает-unsupportedoperationexception)
+ [Реализуйте симметрическую разность двух коллекций используя методы `Collection` (`addAll(...)`, `removeAll(...)`, `retainAll(...)`).](#реализуйте-симметрическую-разность-двух-коллекций-используя-методы-collection-addall-removeall-retainall)
+ [Как, используя LinkedHashMap, сделать кэш c «invalidation policy»?](#как-используя-linkedhashmap-сделать-кэш-c-invalidation-policy)
+ [Как одной строчкой скопировать элементы любой `collection` в массив?](#как-одной-строчкой-скопировать-элементы-любой-collection-в-массив)
+ [Как одним вызовом из `List` получить `List` со всеми элементами, кроме первых и последних 3-х?](#как-одним-вызовом-из-list-получить-list-со-всеми-элементами-кроме-первых-и-последних-3-х)
+ [Как одной строчкой преобразовать `HashSet` в `ArrayList`?](#как-одной-строчкой-преобразовать-hashset-в-arraylist)
+ [Как одной строчкой преобразовать `ArrayList` в `HashSet`?](#как-одной-строчкой-преобразовать-arraylist-в-hashset)
+ [Назовите различия между `HashMap` и `HashSet`?](#назовите-различия-между-hashmap-и-hashset)
+ [Сделайте `HashSet` из ключей `HashMap`.](#сделайте-hashset-из-ключей-hashmap)
+ [Сделайте `HashMap` из `HashSet<Map.Entry<K, V>>`.](#сделайте-hashmap-из-hashsetmapentryk-v)

## Что такое _«коллекция»_?
_«Коллекция»_ - это структура данных, набор каких-либо объектов. Данными (объектами в наборе) могут быть числа, строки, объекты пользовательских классов и т.п.

[к оглавлению](#java-collections-framework)

## Назовите основные интерфейсы JCF и их реализации.
На вершине иерархии в Java Collection Framework располагаются 2 интерфейса: `Collection` и `Map`. Эти интерфейсы разделяют все коллекции, входящие во фреймворк на две части по типу хранения данных: простые последовательные наборы элементов и наборы пар «ключ — значение» соответственно.

Интерфейс `Collection` расширяют интерфейсы:

+ `List` (список) представляет собой коллекцию, в которой допустимы дублирующие значения. Элементы такой коллекции пронумерованы, начиная от нуля, к ним можно обратиться по индексу. Реализации:
    + `ArrayList` - инкапсулирует в себе обычный массив, длина которого автоматически увеличивается при добавлении новых элементов.
    + `LinkedList` (двунаправленный связный список) - состоит из узлов, каждый из которых содержит как собственно данные, так и две ссылки на следующий и предыдущий узел.
    + `Vector` — реализация динамического массива объектов, методы которой синхронизированы.
    + `Stack` — реализация стека LIFO (last-in-first-out).
+ `Set` (сет) описывает неупорядоченную коллекцию, не содержащую повторяющихся элементов. Реализации:
    + `HashSet` - использует HashMap для хранения данных. В качестве ключа и значения используется добавляемый элемент. Из-за особенностей реализации порядок элементов не гарантируется при добавлении.
    + `LinkedHashSet` — гарантирует, что порядок элементов при обходе коллекции будет идентичен порядку добавления элементов.
    + `TreeSet` — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта `Comparator`, либо сохраняет элементы с использованием «natural ordering».
+ `Queue` (очередь) предназначена для хранения элементов с предопределённым способом вставки и извлечения FIFO (first-in-first-out):
    + `PriorityQueue` — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта `Comparator`, либо сохраняет элементы с использованием «natural ordering».
    + `ArrayDeque` — реализация интерфейса `Deque`, который расширяет интерфейс `Queue` методами, позволяющими реализовать конструкцию вида LIFO (last-in-first-out). 

Интерфейс `Map` реализован классами:

+ `Hashtable` — хэш-таблица, методы которой синхронизированы. Не позволяет использовать `null` в качестве значения или ключа и не является упорядоченной.
+ `HashMap` — хэш-таблица. Позволяет использовать `null` в качестве значения или ключа и не является упорядоченной.
+ `LinkedHashMap` — упорядоченная реализация хэш-таблицы.
+ `TreeMap` — реализация основанная на красно-чёрных деревьях. Является упорядоченной и предоставляет возможность управлять порядком элементов в коллекции при помощи объекта `Comparator`, либо сохраняет элементы с использованием «natural ordering».
+ `WeakHashMap` — реализация хэш-таблицы, которая организована с использованием _weak references_ для ключей (сборщик мусора автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элемента нет жёстких ссылок).

[к оглавлению](#java-collections-framework)

## Расположите в виде иерархии следующие интерфейсы: `List`, `Set`, `Map`, `SortedSet`, `SortedMap`, `Collection`, `Iterable`, `Iterator`, `NavigableSet`, `NavigableMap`.
+ `Iterable`
    + `Collection`
        + `List`
        + `Set`
            + `SortedSet`
                + `NavigableSet`
+ `Map`
    + `SortedMap` 
        + `NavigableMap`
+ `Iterator`

[к оглавлению](#java-collections-framework)

## Какие абстрактные классы определяют базовый функционал?

+ `AbstractCollection:` базовый абстрактный класс для других коллекций, который применяет интерфейс Collection

+ `AbstractList:` расширяет класс AbstractCollection и применяет интерфейс List, предназначен для создания коллекций в виде списков

+ `AbstractSet:` расширяет класс AbstractCollection и применяет интерфейс Set для создания коллекций в виде множеств

+ `AbstractQueue:` расширяет класс AbstractCollection и применяет интерфейс Queue, предназначен для создания коллекций в виде очередей и стеков

+ `AbstractSequentialList:` также расширяет класс AbstractList и реализует интерфейс List. Используется для создания связанных списков

+ `AbstractMap:` применяет интерфейс Map, предназначен для создания наборов по типу словаря с объектами в виде пары ""ключ-значение""

[к оглавлению](#java-collections-framework)

## Почему `Map` — это не `Collection`, в то время как `List` и `Set` являются `Collection`?
`Collection` представляет собой совокупность некоторых элементов. `Map` - это совокупность пар «ключ-значение».

[к оглавлению](#java-collections-framework)

## В чем разница между классами `java.util.Collection` и `java.util.Collections`?
`java.util.Collections` - набор статических методов для работы с коллекциями.

`java.util.Collection` - один из основных интерфейсов Java Collections Framework.

[к оглавлению](#java-collections-framework)

## Какие классы коллекций позволяют получить доступ к любому элементу?

Классы `ArrayList`, `HashMap`, `TreeMap`, `Hashtable` позволяют доступ к любому элементу.

[к оглавлению](#java-collections-framework)

## Что такое "потокобезопасные коллекции"?

В Java 1.5 придумали потокобезопасные коллекции, которые позволили изменять содержимое коллекции время итерации по элементам. Наиболее популярными являются: `CopyOnWriteArrayList`, `ConcurrentHashMap`, `CopyOnWriteArraySet`. Эти классы находятся в пакете `java.util.concurrent`. Все классы коллекций находятся в пакетах `java.util` и `java.util.concurrent`.

[к оглавлению](#java-collections-framework)

## Что такое «fail-fast поведение»?
__fail-fast поведение__ означает, что при возникновении ошибки или состояния, которое может привести к ошибке, система немедленно прекращает дальнейшую работу и уведомляет об этом. Использование fail-fast подхода позволяет избежать недетерминированного поведения программы в течение времени.

В Java Collections API некоторые итераторы ведут себя как fail-fast и выбрасывают `ConcurrentModificationException`, если после его создания была произведена модификация коллекции, т.е. добавлен или удален элемент напрямую из коллекции, а не используя методы итератора. 

Реализация такого поведения осуществляется за счет подсчета количества модификаций коллекции (modification count):

+ при изменении коллекции счетчик модификаций так же изменяется;
+ при создании итератора ему передается текущее значение счетчика;
+ при каждом обращении к итератору сохраненное значение счетчика сравнивается с текущим, и, если они не совпадают, возникает исключение.

[к оглавлению](#java-collections-framework)

## Какая разница между fail-fast и fail-safe?
В противоположность fail-fast, итераторы fail-safe не вызывают никаких исключений при изменении структуры, потому что они работают с клоном коллекции вместо оригинала.

[к оглавлению](#java-collections-framework)

## Приведите примеры итераторов реализующих поведение fail-safe
Итератор коллекции `CopyOnWriteArrayList` и итератор представления `keySet` коллекции `ConcurrentHashMap` являются примерами итераторов fail-safe.

[к оглавлению](#java-collections-framework)

## Для чего используется интерфейс `Iterator`?

`Iterator` -это интерфейс, предоставляющий доступ к элементам коллекции и навигацию по ним. Метод `Iterator<E> iterator()` возвращает итератор - то есть объект, реализующий интерфейс `Iterator`.

Реализация интерфейса предполагает, что с помощью вызова метода `next()` можно получить следующий элемент. С помощью метода `hasNext()` можно узнать, есть ли следующий элемент, и не достигнут ли конец коллекции. И если элементы еще имеются, то `hasNext()` вернет значение true. Метод remove() удаляет текущий элемент, который был получен последним вызовом `next()`.

[к оглавлению](#java-collections-framework)

## Что вы знаете об интерфейсе `Iterable`?

Все коллекции из `java.util` реализуют интерфейс `Collection`, который, в свою очередь,
расширяет интерфейс `Iterable`. В интерфейсе `Iterable` описан только один метод: `Iterator iterator()`.
Он возвращает `Iterator`, т.е. объект, который поочерёдно возвращает все элементы коллекции.

[к оглавлению](#java-collections-framework)

## Чем различаются `Enumeration` и `Iterator`.
Хотя оба интерфейса и предназначены для обхода коллекций между ними имеются существенные различия:

+ с помощью `Enumeration` нельзя добавлять/удалять элементы;
+ в `Iterator` исправлены имена методов для повышения читаемости кода (`Enumeration.hasMoreElements()` соответствует `Iterator.hasNext()`, `Enumeration.nextElement()` соответствует `Iterator.next()` и т.д);
+ `Enumeration` присутствуют в устаревших классах, таких как `Vector`/`Stack`, тогда как `Iterator` есть во всех современных классах-коллекциях. 

[к оглавлению](#java-collections-framework)

## Как между собой связаны `Iterable` и `Iterator`?
Интерфейс `Iterable` имеет только один метод - `iterator()`, который возвращает `Iterator`.

[к оглавлению](#java-collections-framework)

## Как между собой связаны `Iterable`, `Iterator` и «for-each»?
Классы, реализующие интерфейс `Iterable`, могут применяться в конструкции `for-each`, которая использует `Iterator`.

[к оглавлению](#java-collections-framework)

## Сравните `Iterator` и `ListIterator`.
+ `ListIterator` расширяет интерфейс `Iterator`
+ `ListIterator` может быть использован только для перебора элементов коллекции `List`;
+ `Iterator` позволяет перебирать элементы только в одном направлении, при помощи метода `next()`. Тогда как `ListIterator` позволяет перебирать список в обоих направлениях, при помощи методов `next()` и `previous()`;
+ `ListIterator` не указывает на конкретный элемент: его текущая позиция располагается между элементами, которые возвращают методы `previous()` и `next()`.
+ При помощи `ListIterator` вы можете модифицировать список, добавляя/удаляя элементы с помощью методов `add()` и `remove()`. `Iterator` не поддерживает данного функционала.

[к оглавлению](#java-collections-framework)

## Что произойдет при вызове `Iterator.next()` без предварительного вызова `Iterator.hasNext()`?
Если итератор указывает на последний элемент коллекции, то возникнет исключение `NoSuchElementException`, иначе будет возвращен следующий элемент.

[к оглавлению](#java-collections-framework)

## Сколько элементов будет пропущено, если `Iterator.next()` будет вызван после 10-ти вызовов `Iterator.hasNext()`?
Нисколько - `hasNext()` осуществляет только проверку наличия следующего элемента.

[к оглавлению](#java-collections-framework)

## Почему не существует метода `Iterator.add()` для добавления элементов в коллекцию?

Единственная задача итератора это перебор коллекции. 
Каждая коллекция имеет метод `add()` которым вы можете воспользоваться. 
Нет смысла добавлять этот метод в итератор, потому что коллекции могут быть упорядоченными и неупорядоченными, 
и метод `add()` при этом должен быть устроен по разному.

[к оглавлению](#java-collections-framework)

## Как поведёт себя коллекция, если вызвать `iterator.remove()`?
Если вызову `iterator.remove()` предшествовал вызов `iterator.next()`, то `iterator.remove()` удалит элемент коллекции, на который указывает итератор, в противном случае будет выброшено `IllegalStateException()`.

[к оглавлению](#java-collections-framework)

## Как поведёт себя уже инстанциированный итератор для `collection`, если вызвать `collection.remove()`?
При следующем вызове методов итератора будет выброшено `ConcurrentModificationException`.

[к оглавлению](#java-collections-framework)

## Как избежать `ConcurrentModificationException` во время перебора коллекции?
+ Попробовать подобрать другой итератор, работающий по принципу fail-safe. К примеру, для `List` можно использовать `ListIterator`.
+ Использовать `ConcurrentHashMap` и `CopyOnWriteArrayList`.
+ Преобразовать список в массив и перебирать массив.
+ Блокировать изменения списка на время перебора с помощью блока `synchronized`.

Отрицательная сторона последних двух вариантов - ухудшение производительности.

[к оглавлению](#java-collections-framework)

## Что такое `UnsupportedOperationException`?

Это исключение возникает при вызове метода, который не поддерживается данной коллекцией. К примеру, если вы создадите список только для чтения с помощью `Collections.unmodifiableList(list)`, а потом у него вызовете метод `add()` или `remove()`, вы точно получите это исключение.

[к оглавлению](#java-collections-framework)

## Что такое очередь и стэк, перечислите разницу между ними?

Коллекции, созданные для того чтобы хранить элементы для дальнейшей обработки. Кроме базовых операций интерфейса `Collection`, очереди поддерживают дополнительные операции добавления, удаления и проверки состояния элемента. Обычно, но не обязательно очереди работают по принципу `FIFO` — первым пришел, первым ушел. Стэк — почти как очередь, но работает по принципу `LIFO` — последним пришел, первым ушел.

Независимо от порядка добавления/удаления, голова очереди это элемент, который будет удален при вызове методов `remove()` или `poll()`. Также обратите внимание на то, что `Stack` и `Vector` оба потокобезопасны.

Использование: Используйте очередь если вы хотите обрабатывать поток элементов в том же порядке в котором они поступают. Хорошо для списка заданий и обработки запросов. Используйте стэк если вы хотите класть и удалять элементы только с вершины стэка, что полезно в рекурсивных алгоритмах.

(А теперь отвлечемся и объясним все чуть иначе. Итак, представьте обойму автомата. Вы вставляете туда патроны по одному, только с одного конца. И с этого же конца, по одному их будет забирать затворный механизм при стрельбе. Это — стэк, положить элемент можно только на его вершину, снять оттуда же и больше ниоткуда. Последний положенный элемент будет снят первым.

Очередь — как трубка, в которую вы можете закатывать шарики, и с другого конца их забирать. Очередь позволяет класть элементы только в свой хвост, а забирать только с головы. Тот элемент который был первым положен, первым же будет и забран.

Общее у очереди и стэка только то, что у них обоих есть фиксированное место куда можно положить элемент, и фиксированное место откуда его можно забрать - все остальные элементы недоступны.

[к оглавлению](#java-collections-framework)

## Какая коллекция реализует дисциплину обслуживания FIFO?
FIFO, First-In-First-Out («первым пришел-первым ушел») - по этому принципу построена коллекция `Queue`.

[к оглавлению](#java-collections-framework)

## Какая коллекция реализует дисциплину обслуживания FILO?
FILO, First-In-Last-Out («первым пришел, последним ушел») - по этому принципу построена коллекция `Stack`.

[к оглавлению](#java-collections-framework)

## Для чего нужен класс `Arrays`?

`java.util.Arrays` - класс, содержащий статические методы для работы с массивами, таких как, например, поиск по массиву и его сортировка.

[к оглавлению](#java-collections-framework)

## В чем разница между классами `java.util.Arrays` и `java.lang.reflect.Array`?

`java.util.Arrays` - класс, содержащий статические методы для работы с массивами,
таких как, например, поиск по массиву и его сортировка.

`java.lang.reflect.Array` - класс для работы с массивами при использовании рефлексии.
Рефлексия - это механизм, позволяющий исследовать данные о программе во время её
выполнения.

[к оглавлению](#java-collections-framework)

## Чем отличается `ArrayList` от `Vector`?
## Зачем добавили `ArrayList`, если уже был `Vector`?
+ Методы класса `Vector` синхронизированы, а `ArrayList` - нет;
+ По умолчанию, `Vector` удваивает свой размер, когда заканчивается выделенная под элементы память. `ArrayList` же увеличивает свой размер только на половину.

`Vector` это устаревший класс и его использование не рекомендовано.

[к оглавлению](#java-collections-framework)

## Почему нельзя написать `ArrayList<List> numbers = new ArrayList<ArrayList>();` но можно `List<ArrayList> numbers = new ArrayList<ArrayList>();`?

Это связано с ограничениями использования generic types (обобщенных типов).
`ArrayList<ArrayList>` не является подтипом `ArrayList<List>`, соответственно использование такой записи запрещено.

[к оглавлению](#java-collections-framework)

## Чем отличается `ArrayList` от `LinkedList`? В каких случаях лучше использовать первый, а в каких второй?
`ArrayList` это список, реализованный на основе массива, а `LinkedList` — это классический двусвязный список, основанный на объектах с ссылками между ними.

`ArrayList`:

+ доступ к произвольному элементу по индексу за время _O(1)_;
+ доступ к элементам по значению за линейное время _O(N)_;
+ вставка в конец в среднем производится за время _O(1)_;
+ удаление произвольного элемента из списка занимает значительное время т.к. при этом все элементы находящиеся «правее» смещаются на одну ячейку влево (реальный размер массива (capacity) не изменяется);
+ вставка элемента в произвольное место списка занимает значительное время т.к. при этом все элементы находящиеся «правее» смещаются на одну ячейку вправо;
+ минимум накладных расходов при хранении.

`LinkedList`:

+ на получение элемента по индексу или значению потребуется линейное время _O(N)_;
+ на добавление и удаление в начало или конец списка потребуется _O(1)_;
+ вставка или удаление в/из произвольного место _O(N)_;
+ требует больше памяти для хранения такого же количества элементов, потому что кроме самого элемента хранятся еще указатели на следующий и предыдущий элементы списка.

В целом, `LinkedList` в абсолютных величинах проигрывает `ArrayList` и по потребляемой памяти и по скорости выполнения операций. `LinkedList` предпочтительно применять, когда нужны частые операции вставки/удаления или в случаях, когда необходимо гарантированное время добавления элемента в список.

[к оглавлению](#java-collections-framework)

## Что работает быстрее `ArrayList` или `LinkedList`?
Смотря какие действия будут выполняться над структурой. 

см. [Чем отличается `ArrayList` от `LinkedList`](#чем-отличается-arraylist-от-linkedlist-В-каких-случаях-лучше-использовать-первый-а-в-каких-второй)

[к оглавлению](#java-collections-framework)

## Оцените ассимптотическую сложность работы `ArrayList` и `LinkedList`

Чтобы оценить эти структуры данных, можно прибегнуть к ассимптотической сложности выполнения операций:

```
                          |  ArrayList  |  LinkedList 
 add (в начало)           |     O(n)    |   O(1)
 add (в середину)         |     O(n)    |   O(n)
 add (в конец списка)     |     O(n)    |   O(1)   
 ```
В `LinkedList` вставка осуществляется так: находится элемент, за которым должен следовать вставляемый элемент, изменяются ссылки в нем и следующим за ним.

В `ArrayList` создается новый массив, если в текущем нет места. Те элементы которые находятся до вставляемого, остаются на месте, или копируются в новый. Далее добавляется вставляемый элемент. Затем копируются оставщиеся элементы, которые были в исходном.
```
get (первый элемент)        |   O(1)    |   O(1)
get (из середины)           |   O(1)    |   O(n)
get (последний элемент)     |   O(1)    |   O(1)
```
В `LinkedList` чтобы найти элемент с нужным индексом, нужно пройтись поочередно по ссылкам от первого элемента и до последнего (в худшем случае). В ArrayList получения элемента происходит простым взятием по индексу из массива.
```
delete (первый элемент)     |   O(n)    |   O(1)
delete (из середины)        |   O(n)    |   O(n)
delete (последний элемент)  |   O(1)    |   O(1)
```

[к оглавлению](#java-collections-framework)

## Какое худшее время работы метода `contains()` для элемента, который есть в `LinkedList`?
_O(N)_. Время поиска элемента линейно пропорционально количеству элементов с списке.

[к оглавлению](#java-collections-framework)

## Какое худшее время работы метода `contains()` для элемента, который есть в `ArrayList`?
_O(N)_. Время поиска элемента линейно пропорционально количеству элементов с списке.

[к оглавлению](#java-collections-framework)

## Какое худшее время работы метода `add()` для `LinkedList`?
_O(N)_. Добавление в начало/конец списка осуществляется за время _O(1)_.

[к оглавлению](#java-collections-framework)

## Какое худшее время работы метода `add()` для `ArrayList`?
_O(N)_. Вставка элемента в конец списка осуществляется за время _O(1)_, но если вместимость массива недостаточна, то происходит создание нового массива с увеличенным размером и копирование всех элементов из старого массива в новый.

[к оглавлению](#java-collections-framework)

## Необходимо добавить 1 млн. элементов, какую структуру вы используете?
Однозначный ответ можно дать только исходя из информации о том в какую часть списка происходит добавление элементов, что потом будет происходить с элементами списка, существуют ли какие-то ограничения по памяти или скорости выполнения.

см. [Чем отличается `ArrayList` от `LinkedList`](#чем-отличается-arraylist-от-linkedlist-В-каких-случаях-лучше-использовать-первый-а-в-каких-второй)

[к оглавлению](#java-collections-framework)

## Как происходит удаление элементов из `ArrayList`? Как меняется в этом случае размер `ArrayList`?

При удалении произвольного элемента из списка, все элементы находящиеся «правее» смещаются на одну ячейку влево и реальный размер массива (его емкость, capacity) не изменяется никак. Механизм автоматического «расширения» массива существует, а вот автоматического «сжатия» нет, можно только явно выполнить «сжатие» командой `trimToSize()`.

[к оглавлению](#java-collections-framework)

## Предложите эффективный алгоритм удаления нескольких рядом стоящих элементов из середины списка, реализуемого `ArrayList`.
Допустим нужно удалить `n` элементов с позиции `m` в списке. Вместо выполнения удаления одного элемента `n` раз (каждый раз смещая на 1 позицию элементы, стоящие «правее» в списке), нужно выполнить смещение всех элементов, стоящих «правее» `n + m` позиции на `n` элементов «левее» к началу списка. Таким образом, вместо выполнения `n` итераций перемещения элементов списка, все выполняется за 1 проход.

[к оглавлению](#java-collections-framework)

## Сколько необходимо дополнительной памяти при вызове `ArrayList.add()`?
Если в массиве достаточно места для размещения нового элемента, то дополнительной памяти не требуется. Иначе происходит создание нового массива размером в 1,5 раза превышающим существующий (это верно для JDK выше 1.7, в более ранних версиях размер увеличения иной).

[к оглавлению](#java-collections-framework)

## Сколько выделяется дополнительно памяти при вызове `LinkedList.add()`?
Создается один новый экземпляр вложенного класса `Node`.

[к оглавлению](#java-collections-framework)

## Оцените количество памяти на хранение одного примитива типа `byte` в `LinkedList`?
Каждый элемент `LinkedList` хранит ссылку на предыдущий элемент, следующий элемент и ссылку на данные.

```java
private static class Node<E> {
        E item;
        Node<E> next;
        Node<E> prev;
//...
}
```

Для 32-битных систем каждая ссылка занимает 32 бита (4 байта). Сам объект (заголовок) вложенного класса `Node` занимает 8 байт. 4 + 4 + 4 + 8 = 20 байт, а т.к. размер каждого объекта в Java кратен 8, соответственно получаем 24 байта. Примитив типа `byte` занимает 1 байт памяти, но в JCF примитивы упаковываются: объект типа `Byte` занимает в памяти 16 байт (8 байт на заголовок объекта, 1 байт на поле типа `byte` и 7 байт для кратности 8). Также напомню, что значения от -128 до 127 кэшируются и для них новые объекты каждый раз не создаются. Таким образом, в x32 JVM 24 байта тратятся на хранение одного элемента в списке и 16 байт - на хранение упакованного объекта типа `Byte`. Итого 40 байт.

Для 64-битной JVM каждая ссылка занимает 64 бита (8 байт), размер заголовка каждого объекта составляет 16 байт (два машинных слова). Вычисления аналогичны: 8 + 8 + 8 + 16 = 40байт и 24 байта. Итого 64 байта.

[к оглавлению](#java-collections-framework)

## Оцените количество памяти на хранение одного примитива типа `byte` в `ArrayList`?
`ArrayList` основан на массиве, для примитивных типов данных осуществляется автоматическая упаковка значения, поэтому 16 байт тратится на хранение упакованного объекта и 4 байта (8 для x64) - на хранение ссылки на этот объект в самой структуре данных. Таким образом, в x32 JVM 4 байта используются на хранение одного элемента и 16 байт - на хранение упакованного объекта типа `Byte`. Для x64 - 8 байт и 24 байта соотвтетсвенно.

[к оглавлению](#java-collections-framework)

## Для `ArrayList` или для `LinkedList` операция добавления элемента в середину (`list.add(list.size()/2, newElement)`) медленнее?
Для `ArrayList`:

+ проверка массива на вместимость. Если вместимости недостаточно, то увеличение размера массива и копирование всех элементов в новый массив (_O(N)_);
+ копирование всех элементов, расположенных правее от позиции вставки, на одну позицию вправо (_O(N)_);
+ вставка элемента (_O(1)_).

Для `LinkedList`:

+ поиск позиции вставки (_O(N)_);
+ вставка элемента (_O(1)_).

В худшем случае вставка в середину списка эффективнее для `LinkedList`. В остальных - скорее всего, для `ArrayList`, поскольку копирование элементов осуществляется за счет вызова быстрого системного метода `System.arraycopy()`.

[к оглавлению](#java-collections-framework)

## В реализации класса `ArrayList` есть следующие поля: `Object[] elementData`, `int size`. Объясните, зачем хранить отдельно `size`, если всегда можно взять `elementData.length`?
Размер массива `elementData` представляет собой вместимость (capacity) `ArrayList`, которая всегда больше переменной `size` - реального количества хранимых элементов. При необходимости вместимость автоматически возрастает.

[к оглавлению](#java-collections-framework)

## Сравните интерфейсы `Queue` и `Deque`.

[к оглавлению](#java-collections-framework)

## Кто кого расширяет: `Queue` расширяет `Deque`, или `Deque` расширяет `Queue`?
`Queue` - это очередь, которая обычно (но необязательно) строится по принципу FIFO (First-In-First-Out) - соответственно извлечение элемента осуществляется с начала очереди, вставка элемента - в конец очереди. Хотя этот принцип нарушает, к примеру `PriorityQueue`, использующая «natural ordering» или переданный `Comparator` при вставке нового элемента.

`Deque` (Double Ended Queue) расширяет `Queue` и согласно документации это линейная коллекция, поддерживающая вставку/извлечение элементов с обоих концов. Помимо этого реализации интерфейса `Deque` могут строится по принципу FIFO, либо LIFO.

Реализации и `Deque`, и `Queue` обычно не переопределяют методы `equals()` и `hashCode()`, вместо этого используются унаследованные методы класса Object, основанные на сравнении ссылок.

[к оглавлению](#java-collections-framework)

## Расскажите про класс `ArrayDeque`

В Java очереди представлены рядом классов. Одни из низ - класс `ArrayDeque<E>`. Этот класс представляют обобщенную двунаправленную очередь, наследуя функционал от класса `AbstractCollection` и применяя интерфейс `Deque`.

В классе `ArrayDeque` определены следующие конструкторы:

+ `ArrayDeque()`: создает пустую очередь
+ `ArrayDeque(Collection<? extends E> col)`: создает очередь, наполненную элементами из коллекции col
+ `ArrayDeque(int capacity)`: создает очередь с начальной емкостью capacity. Если мы явно не указываем начальную емкость, то емкость по умолчанию будет равна 16"

[к оглавлению](#java-collections-framework)

## Что такое `BlockingQueue`?

Это очередь, которая позволяет обрабатывать ситуации, когда из пустой очереди пытаются получить элемент,
 или когда пытаются добавить элемент в очередь, а место в ней закончилось. 
 
 Методы блокирующей очереди могут быть четырех типов: 
 Первые вызывают исключение, вторые возвращают специальные значения 
 (`null` или `false`, в зависимости от операции), третьи блокируют текущий поток до тех пор пока операция не может быть выполнена,
  и четвертые блокируют поток только на определенный промежуток времени.

[к оглавлению](#java-collections-framework)

## Расскажите про класс `LinkedList`

Обобщенный класс `LinkedList<E>` представляет структуру данных в виде связанного списка. 

Он наследуется от класса `AbstractSequentialList` и реализует интерфейсы `List`, `Dequeue` и `Queue`. То есть он соединяет функциональность работы со списком и фукциональность очереди.

[к оглавлению](#java-collections-framework)

## Почему `LinkedList` реализует и `List`, и `Deque`?
`LinkedList` позволяет добавлять элементы в начало и конец списка за константное время, что хорошо согласуется с поведением интерфейса `Deque`.

[к оглавлению](#java-collections-framework)

## `LinkedList` — это односвязный, двусвязный или четырехсвязный список?
`Двусвязный`: каждый элемент `LinkedList` хранит ссылку на предыдущий и следующий элементы.

[к оглавлению](#java-collections-framework)

## Как перебрать элементы `LinkedList` в обратном порядке, не используя медленный `get(index)`?
Для этого в `LinkedList` есть обратный итератор, который можно получить вызва метод `descendingIterator()`.

[к оглавлению](#java-collections-framework)

## Что позволяет сделать `PriorityQueue`?
Особенностью `PriorityQueue` является возможность управления порядком элементов. По-умолчанию, элементы сортируются с использованием «natural ordering», но это поведение может быть переопределено при помощи объекта `Comparator`, который задаётся при создании очереди. Данная коллекция не поддерживает null в качестве элементов.

Используя `PriorityQueue`, можно, например, реализовать алгоритм Дейкстры для поиска кратчайшего пути от одной вершины графа к другой. Либо для хранения объектов согласно определённого свойства.

[к оглавлению](#java-collections-framework)

## `Stack` считается «устаревшим». Чем его рекомендуют заменять? Почему?
`Stack` был добавлен в Java 1.0 как реализация стека LIFO (last-in-first-out) и является расширением коллекции `Vector`, хотя это несколько нарушает понятие стека (например, класс `Vector` предоставляет возможность обращаться к любому элементу по индексу). Является частично синхронизированной коллекцией (кроме метода добавления `push()`) с вытекающими отсюда последствиями в виде негативного воздействия на производительность. После добавления в Java 1.6 интерфейса `Deque`, рекомендуется использовать реализации именно этого интерфейса, например `ArrayDeque`.

[к оглавлению](#java-collections-framework)

## Для чего нужен интерфейс `Map`

`Интерфейс Map<K, V>` представляет отображение или иначе говоря словарь, где каждый элемент представляет пару ""ключ-значение"". При этом все ключи уникальные в рамках объекта `Map`. Такие коллекции облегчают поиск элемента, если нам известен ключ - уникальный идентификатор объекта.
Следует отметить, что в отличие от других интерфейсов, которые представляют коллекции, интерфейс `Map` НЕ расширяет интерфейс `Collection`.

Чтобы положить объект в коллекцию, используется метод `put()`, а чтобы получить по ключу - метод `get()`. Реализация интерфейса `Map` также позволяет получить наборы как ключей, так и значений. А метод `entrySet()` возвращает набор всех элементов в виде объектов `Map.Entry<K, V>`.

[к оглавлению](#java-collections-framework)

## Назовите различия между `List` и `Map`?

Список это коллекция элементов, а словарь это коллекция пар ключ/значение. 

Есть еще множество изменений, но все они являются следствием данного. У них разный интерфейс верхнего уровня, разный набор методов и разные представления данных. В большинстве случаев достаточно только первого ответа.

[к оглавлению](#java-collections-framework)

## Зачем нужен `HashMap`, если есть `Hashtable`?
+ Методы класса `Hashtable` синхронизированы, что приводит к снижению производительности, а `HashMap` - нет;
+ `HashTable` не может содержать элементы `null`, тогда как `HashMap` может содержать один ключ `null` и любое количество значений `null`;
+ Iterator у `HashMap`, в отличие от Enumeration у `HashTable`, работает по принципу «fail-fast» (выдает исключение при любой несогласованности данных).

`Hashtable` это устаревший класс и его использование не рекомендовано.

[к оглавлению](#java-collections-framework)

## Различия между `HashMap` и `Collection.synchronizedMap(HashMap)`

`HashMap` не синхронизирована и `Collection.synchronizedMap(HashMap)` возвращает упакованные методы HashMap которые являются синхронизированными `get` и `put` методами.

Фактически, `Collection.synchronizedMap(HashMap)` внутренне созданного внутреннего класса `SunchronizedMap` содержащего пары key-value передающиеся в `HashMap` как аргумент. Такой пример внутренних классов ничего не меняет в первоначальных параметрах `HashMap` и является полностью независимым.

[к оглавлению](#java-collections-framework)

## Различия между `HashTable` и `Collection.synchronized(HashMap)`

Оба являются синхронизированными версиями коллекций. Оба имеют синхронизированные методы внутри. Оба блокируют потоки и заставляют ждать когда можно взять/положить что-либо в коллекцию. Так в чем же различия? Хорошо! Нет основных различий для указанных выше причин. Производительность обоих одинакова. 

Единственное что различает их это то что `HashTable` наследуемый класс он получил свои дополнительные функции такие как `Enumerators` (счетчики).

[к оглавлению](#java-collections-framework)

## В чем разница между `HashMap` и `IdentityHashMap`? Для чего нужна `IdentityHashMap`?
`IdentityHashMap` - это структура данных, так же реализующая интерфейс `Map` и использующая при сравнении ключей (значений) сравнение ссылок, а не вызов метода `equals()`. Другими словами, в `IdentityHashMap` два ключа `k1` и `k2` будут считаться равными, если они указывают на один объект, т.е. выполняется условие `k1` == `k2`.

`IdentityHashMap` не использует метод `hashCode()`, вместо которого применяется метод `System.identityHashCode()`, по этой причине `IdentityHashMap` по сравнению с `HashMap` имеет более высокую производительность, особенно если последний хранит объекты с дорогостоящими методами `equals()` и `hashCode()`.

Одним из основных требований к использованию `HashMap` является неизменяемость ключа, а, т.к. `IdentityHashMap` не использует методы  `equals()` и `hashCode()`, то это правило на него не распространяется.

`IdentityHashMap` может применяться для реализации сериализации/клонирования. При выполнении подобных алгоритмов программе необходимо обслуживать хэш-таблицу со всеми ссылками на объекты, которые уже были обработаны. Такая структура не должна рассматривать уникальные объекты как равные, даже если метод `equals()` возвращает `true`.

[к оглавлению](#java-collections-framework)

## В чем разница между `HashMap` и `WeakHashMap`? Для чего используется `WeakHashMap`?
В Java существует 4 типа ссылок: _сильные (strong reference)_, _мягкие (SoftReference)_, _слабые (WeakReference)_ и _фантомные (PhantomReference)_. Особенности каждого типа ссылок связаны с работой Garbage Collector. Если объект можно достичь только с помощью цепочки WeakReference (то есть на него отсутствуют сильные и мягкие ссылки), то данный объект будет помечен на удаление.

`WeakHashMap` - это структура данных, реализующая интерфейс `Map` и основанная на использовании WeakReference для хранения ключей. Таким образом, пара «ключ-значение» будет удалена из `WeakHashMap`, если на объект-ключ более не имеется сильных ссылок.

В качестве примера использования такой структуры данных можно привести следующую ситуацию: допустим имеются объекты, которые необходимо расширить дополнительной информацией, при этом изменение класса этих объектов нежелательно либо невозможно. В этом случае добавляем каждый объект в `WeakHashMap` в качестве ключа, а в качестве значения - нужную информацию. Таким образом, пока на объект имеется сильная ссылка (либо мягкая), можно проверять хэш-таблицу и извлекать информацию. Как только объект будет удален, то WeakReference для этого ключа будет помещен в ReferenceQueue и затем соответствующая запись для этой слабой ссылки будет удалена из `WeakHashMap`.

[к оглавлению](#java-collections-framework)

## В чем разница между `HashMap` и `ConcurrentHashMap`?

Чтобы лучше визуализировать `СoncurrentHashMap` нужно рассматривать этот класс как группу HashMap’ов. 
Чтобы брать и класть значения пар(key-value) в HashMap необходимо вычислить хэш-код и найти правильный сегмент массива `Collection.Entry`. 

В `ConcurrentHashMap` отличие заключается во внутренней структуре для хранения пар key-value. `ConcurrentHashMap` имеет дополнительную концепцию сегментов. 
Будет легко понять если представить, что один сегмент эквивалентен одному HashMap(концептуально). `ConcurrentHashMap` разделена на множество сегментов (по умолчанию их число равно 16) при инициализации. `ConcurrentHashMap` похожим потокам примерно (16) получать одновременный доступ к этому сегменту, каждый поток работает одновременно с высоким параллелизмом. Отсюда, если ваша пара key-value хранится в сегменте 10 не нужно блокировать остальные 15 сегментов дополнительно. Такая структура обеспечивает очень высокий уровень параллелизма.

Другими словами `ConcurrentHashMap` использует множество замков и каждый замок управляет одним сегментом структуры. Установки данных в определенном сегменте заблокированы для получения в этом сегменте так синхронизированы операции обновления. При получении данных, чтения на лету используется без синхронизации. Если считывать данные на лету то сегмент блокируется и запись производится в синхронизированный блок.

[к оглавлению](#java-collections-framework)

## В `WeakHashMap` используются WeakReferences. А почему бы не создать `SoftHashMap` на SoftReferences?
`SoftHashMap` представлена в сторонних библиотеках, например, в `Apache Commons`.

[к оглавлению](#java-collections-framework)

## В `WeakHashMap` используются WeakReferences. А почему бы не создать `PhantomHashMap` на PhantomReferences?
PhantomReference при вызове метода `get()` возвращает всегда `null`, поэтому тяжело представить назначение такой структуры данных.

[к оглавлению](#java-collections-framework)

## `LinkedHashMap` - что в нем от `LinkedList`, а что от `HashMap`?
Реализация `LinkedHashMap` отличается от `HashMap` поддержкой двухсвязанного списка, определяющего порядок итерации по элементам структуры данных. По умолчанию элементы списка упорядочены согласно их порядку добавления в `LinkedHashMap` (insertion-order). Однако порядок итерации можно изменить, установив параметр конструктора `accessOrder` в значение `true`. В этом случае доступ осуществляется по порядку последнего обращения к элементу (access-order). Это означает, что при вызове методов `get()` или `put()` элемент, к которому обращаемся, перемещается в конец списка.

При добавлении элемента, который уже присутствует в `LinkedHashMap` (т.е. с одинаковым ключом), порядок итерации по элементам не изменяется.

[к оглавлению](#java-collections-framework)

## Говорят, на `LinkedHashMap` легко сделать простенький кэш c "invalidation policy", знаете как?

Необходимо использовать LRU-алгоритм (Least Recently Used algorithm) и
`LinkedHashMap` с access-order. В этом случае при обращении к элементу он будет
перемещаться в конец списка, а наименее используемые элементы будут постепенно
группироваться в начале списка.

Для этого в стандартной реализации `LinkedHashMap` (source) есть метод
`removeEldestEntries()`, который возвращает true, если текущий объект `LinkedHashMap`
должен удалить наименее используемый элемент из коллекции. Метод вызывается при
использовании методов `put()` и `putAll()`.

Стоит заметить, что `LinkedHashMap` не позволяет полностью реализовать LRU-алгоритм, поскольку при вставке уже имеющегося в коллекции элемента порядок
итерации не меняется.

[к оглавлению](#java-collections-framework)

## Какая особенность интерфейса `SortedMap`?

Интерфейс `SortedMap` расширяет `Map` и создает отображение, в котором все элементы отсортированы в порядке возрастания их ключей.

[к оглавлению](#java-collections-framework)

## Какая особенность интерфейса `NavigableMap`?

Интерфейс `NavigableMap` расширяет интерфейс `SortedMap` и обеспечивает возможность получения элементов отображения относительно других элементов. 

[к оглавлению](#java-collections-framework)

## В чем проявляется «сортированность» `SortedMap`, кроме того, что `toString()` выводит все элементы по порядку?
Так же оно проявляется при итерации по коллекции.

[к оглавлению](#java-collections-framework)

## Как устроен `HashMap`?
`HashMap` состоит из «корзин» (bucket). С технической точки зрения «корзины» — это элементы массива, которые хранят ссылки на списки элементов. При добавлении новой пары «ключ-значение», вычисляет хэш-код ключа, на основании которого вычисляется номер корзины (номер ячейки массива), в которую попадет новый элемент. Если корзина пустая, то в нее сохраняется ссылка на вновь добавляемый элемент, если же там уже есть элемент, то происходит последовательный переход по ссылкам между элементами в цепочке, в поисках последнего элемента, от которого и ставится ссылка на вновь добавленный элемент. Если в списке был найден элемент с таким же ключом, то он заменяется.

[к оглавлению](#java-collections-framework)

## Опишите процесс создания ключа для `HashMap`

Одной из главных необходимостей является то, что мы должны возвращать значение объекта без ошибок. Правильно? В противном случае непонятно как представить себе структуру данных которую вы проектируете. Это будет невозможно использовать. Чтобы решить, что мы создали хороший ключ мы должны знать как работает `HashMap`. Работа `HashMap` построена на принципах Хеширования. Ключ в хэш-коде используются прежде всего в сочетании с методом `equals()`, для добавления и поиска элемента по `HashMap`. Если хэш-код объекта меняется на другую пару ключ – значение(key-value), то значение от карты(Map) получить практически невозможно. Данный случай называется утечкой памяти. Чтобы избежать этого ключ и карта должны быть неизменны. Это главная причина того что неизменяемые классы такие как `String`, `Integer` и остальные классы подобного рода являются хорошим выбором для создания ключа.

Но нужно помнить, что неизменность рекомендована, но не является обязательной. Если ты хочешь сделать ключом изменяемый объект, тогда ты должен убедиться в том, что ключевой объект не меняет хэш-код объекта. Это может быть сделано путем переопределения метода `hashCode()`. Кроме того ключевые классы должны работать корректно с методами `hashCode()` и `equals()` чтобы избежать нежелательного и удивительного поведения при выполнении.

[к оглавлению](#java-collections-framework)

## Влияние случайных/фиксированных значений для значения ключа

Влияние в обоих случаях будь то фиксированное значение или случайное будет иметь одинаковый результат и это необъяснимое поведение. Большое значение имеет место в `HashMap` где поставить пару key-value и где восстановить. Если положение объекта ключа меняется каждый раз то его положение будет рассчитываться каждый раз разными способами. Таким образом объект хранящийся в `HashMap` будет потерян навсегда с минимальной возможностью восстановления. Поэтому значения ключей являются неизменными и каждый раз возвращают уникальные значения.

[к оглавлению](#java-collections-framework)

## Как устроен `TreeMap`?

Класс `TreeMap<K, V>` представляет отображение в виде дерева. Он наследуется от класса `AbstractMap` и реализует интерфейс` NavigableMap`, а следовательно, также и интерфейс `SortedMap`. Поэтому в отличие от коллекции `HashMap`, в `TreeMap` все объекты автоматически сортируются по возрастанию их ключей.

Кроме собственно методов интерфейса `Map`, класс `TreeMap` реализует методы интерфейса `NavigableMap`. Например, мы можем получить все объекты до или после определенного ключа с помощью методов `headMap` и `tailMap`. Также мы можем получить первый и последний элементы и провести ряд дополнительных манипуляций с объектами.

[к оглавлению](#java-collections-framework)

## Согласно Кнуту и Кормену существует две основных реализации хэш-таблицы: на основе открытой адресации и на основе метода цепочек. Как реализована `HashMap`? Почему, по вашему мнению, была выбрана именно эта реализация? В чем плюсы и минусы каждого подхода?
`HashMap` реализован с использованием метода цепочек, т.е. каждой ячейке массива (корзине) соответствует свой связный список и при возникновении коллизии осуществляется добавление нового элемента в этот список.

Для метода цепочек коэффициент заполнения может быть больше 1 и с увеличением числа элементов производительность убывает линейно. Такие таблицы удобно использовать, если заранее неизвестно количество хранимых элементов, либо их может быть достаточно много, что приводит к большим значениям коэффициента заполнения.

Среди методов открытой реализации различают:

+ линейное пробирование;
+ квадратичное пробирование;
+ двойное хэширование.

Недостатки структур с методом открытой адресации:

+ Количество элементов в хэш-таблице не может превышать размера массива. По мере увеличения числа элементов и повышения коэффициента заполнения производительность структуры резко падает, поэтому необходимо проводить перехэширование.
+ Сложно организовать удаление элемента.
+ Первые два метода открытой адресации приводят к проблеме первичной и вторичной группировок.

Преимущества хэш-таблицы с открытой адресацией: 

+ отсутствие затрат на создание и хранение объектов списка; 
+ простота организации сериализации/десериализации объекта.

[к оглавлению](#java-collections-framework)

## Как работает `HashMap` при попытке сохранить в него два элемента по ключам с одинаковым `hashCode()`, но для которых `equals() == false`?
По значению `hashCode()` вычисляется индекс ячейки массива, в список которой этот элемент будет добавлен. Перед добавлением осуществляется проверка на наличие элементов в этой ячейке. Если элементы с таким `hashCode()` уже присутствует, то осуществляется обход списка со сравнением по `equals()` в поисках идентичного элемента. Т.к. `equals() == false`, - элемент будет добавлен в начало списка.

[к оглавлению](#java-collections-framework)

## Какое начальное количество корзин в `HashMap`?
В конструкторе по умолчанию - 16, используя конструкторы с параметрами можно задавать произвольное начальное количество корзин.

[к оглавлению](#java-collections-framework)

## Какова оценка временной сложности операций над элементами из `HashMap`? Гарантирует ли `HashMap` указанную сложность выборки элемента?
В общем случае операции добавления, поиска и удаления элементов занимают константное время. 

Данная сложность не гарантируется, т.к. если хэш-функция распределяет элементы по корзинам равномерно, временная сложность станет не хуже _O(lg(N))_, а в случае, когда хэш-функция постоянно возвращает одно и то же значение `HashMap` превратится в связный список со сложностью О(n) .

[к оглавлению](#java-collections-framework)

## Возможна ли ситуация, когда `HashMap` выродится в список даже с ключами имеющими разные `hashCode()`?
Это возможно в случае, если метод, определяющий номер корзины будет возвращать одинаковые значения.

[к оглавлению](#java-collections-framework)

## В каком случае может быть потерян элемент в `HashMap`?
Допустим, в качестве ключа используется не примитив, а объект с несколькими полями. После добавления элемента в `HashMap` у объекта, который выступает в качестве ключа, изменяют одно поле, которое участвует в вычислении хэш-кода. В результате при попытке найти данный элемент по исходному ключу, будет происходить обращение к правильной корзине, а вот `equals` уже не найдет указанный ключ в списке элементов. Тем не менее, даже если `equals` реализован таким образом, что изменение данного поля объекта не влияет на результат, то после увеличения размера корзин и пересчета хэш-кодов элементов, указанный элемент, с измененным значением поля, с большой долей вероятности попадет в совершенно другую корзину и тогда уже потеряется совсем.

[к оглавлению](#java-collections-framework)

## Почему нельзя использовать `byte[]` в качестве ключа в `HashMap`?
Хэш-код массива не зависит от хранимых в нем элементов, а присваивается при создании массива (метод вычисления хэш-кода массива не переопределен и вычисляется по стандартному `Object.hashCode()` на основании адреса массива). Так же у массивов не переопределен `equals` и выполняется сравнение указателей. Это приводит к тому, что обратиться к сохраненному с ключом-массивом элементу не получится при использовании другого массива такого же размера и с такими же элементами, доступ можно осуществить лишь в одном случае — при использовании той же самой ссылки на массив, что использовалась для сохранения элемента.

[к оглавлению](#java-collections-framework)

## Какова роль `equals()` и `hashCode()` в `HashMap`?
`hashCode` позволяет определить корзину для поиска элемента, а `equals` используется для сравнения ключей элементов в списке корзины и искомого ключа.

[к оглавлению](#java-collections-framework)

## Каково максимальное число значений `hashCode()`?
Число значений следует из сигнатуры `int hashCode()` и равно диапазону типа `int` — __2<sup>32</sup>__.

[к оглавлению](#java-collections-framework)

## Какое худшее время работы метода get(key) для ключа, которого нет в `HashMap`?
## Какое худшее время работы метода get(key) для ключа, который есть в `HashMap`?
___O(N)___. Худший случай - это поиск ключа в `HashMap`, вырожденного в список по причине совпадения ключей по `hashCode()` и для выяснения хранится ли элемент с определённым ключом может потребоваться перебор всего списка.

[к оглавлению](#java-collections-framework)

## Сколько переходов происходит в момент вызова `HashMap.get(key)` по ключу, который есть в таблице?
+ ключ равен `null`: __1__ - выполняется единственный метод `getForNullKey()`.
+ любой ключ отличный от `null`: __4__ - вычисление хэш-кода ключа; определение номера корзины; поиск значения; возврат значения.

[к оглавлению](#java-collections-framework)

## Сколько создается новых объектов, когда вы добавляете новый элемент в `HashMap`?
__Один__ новый объект статического вложенного класса `Entry<K,V>`.

[к оглавлению](#java-collections-framework)

## Как и когда происходит увеличение количества корзин в `HashMap`?
Помимо `capacity` у `HashMap` есть еще поле `loadFactor`, на основании которого, вычисляется предельное количество занятых корзин `capacity * loadFactor`. По умолчанию `loadFactor = 0.75`. По достижению предельного значения, число корзин увеличивается в 2 раза и для всех хранимых элементов вычисляется новое «местоположение» с учетом нового числа корзин.

[к оглавлению](#java-collections-framework)

## Объясните смысл параметров в конструкторе `HashMap(int initialCapacity, float loadFactor)`.
+ `initialCapacity` - исходный размер `HashMap`, количество корзин в хэш-таблице в момент её создания.
+ `loadFactor` - коэффициент заполнения `HashMap`, при превышении которого происходит увеличение количества корзин и автоматическое перехэширование. Равен отношению числа уже хранимых элементов в таблице к её размеру. 

[к оглавлению](#java-collections-framework)

## Будет ли работать `HashMap`, если все добавляемые ключи будут иметь одинаковый `hashCode()`?

Да, будет, но в этом случае `HashMap` вырождается в связный список и теряет свои преимущества.

[к оглавлению](#java-collections-framework)

## Как перебрать все ключи `Map`?

Использовать метод `keySet()`, который возвращает множество `Set<K>` ключей.

[к оглавлению](#java-collections-framework)

## Как перебрать все значения `Map`?
Использовать метод `values()`, который возвращает коллекцию `Collection<V>` значений.

[к оглавлению](#java-collections-framework)

## Как перебрать все пары «ключ-значение» в `Map`?
Использовать метод `entrySet()`, который возвращает множество `Set<Map.Entry<K, V>` пар «ключ-значение».

[к оглавлению](#java-collections-framework)

## Интерфейс `Set` и класс `HashSet`

Интерфейс `Set` расширяет интерфейс `Collection` и представляет набор уникальных элементов. `Set` не добавляет новых методов, только вносит изменения унаследованные. В частности, метод add() добавляет элемент в коллекцию и возвращает true, если в коллекции еще нет такого элемента.

Обобщенный класс `HashSet` представляет хеш-таблицу. Он наследует свой функционал от класса `AbstractSet`, а также реализует интерфейс `Set`.

Хеш-таблица представляет такую структуру данных, в которой все объекты имеют уникальный ключ или хеш-код. Данный ключ позволяет уникально идентифицировать объект в таблице.

[к оглавлению](#java-collections-framework)

## Назовите отличия между `Set` и `List`

Список ключевых различий:

Множества — неупорядоченные коллекции, тогда как списки — упорядоченные, где каждый элемент имеет индекс начинающийся с нуля. 

Списки могут содержать два и более одинаковых элемента, а множества не могут. 

В списке может содержаться сколько угодно элементов null, в множестве — только один.

[к оглавлению](#java-collections-framework)

## В чем отличия `TreeSet` и `HashSet`?
`TreeSet` обеспечивает упорядоченно хранение элементов в виде красно-черного дерева. Сложность выполнения основных операций не хуже _O(lg(N))_. 

`HashSet` использует для хранения элементов такой же подход, что и `HashMap`, за тем отличием, что в `HashSet` в качестве ключа и значения выступает сам `элемент`, кроме того `HashSet` не поддерживает упорядоченное хранение элементов и обеспечивает временную сложность выполнения операций аналогично `HashMap`.

[к оглавлению](#java-collections-framework)

## Что будет, если добавлять элементы в `TreeSet` по возрастанию?
В основе `TreeSet` лежит красно-черное дерево, которое умеет само себя балансировать. В итоге, `TreeSet` все равно в каком порядке вы добавляете в него элементы, преимущества этой структуры данных будут сохраняться.

[к оглавлению](#java-collections-framework)

## Что вы знаете про интерфейс `SortedSet`?

Интерфейс `SortedSet` предназначен для создания коллекций, который хранят элементы в отсортированном виде (сортировка по возрастанию). 

`SortedSet` расширяет интерфейс `Set`, поэтому такая коллекция опять же хранит только уникальные значения. 

[к оглавлению](#java-collections-framework)

## Назовите различия между `TreeSet` и `SortedSet`?

`SortedSet` это интерфейс, реализуемый классом `TreeSet`. Вот и все!

[к оглавлению](#java-collections-framework)

## Что вы знаете про интерфейс `NavigableSet`?

Интерфейс `NavigableSet` расширяет интерфейс `SortedSet` и позволяет извлекать элементы на основании их значений. 
Расширяет методы навигации находя ближайшее совпадение по заданному значению. И сродни родительскому интерфейсу в `NavigableSet` не может быть дубликатов.

[к оглавлению](#java-collections-framework)

## Чем `LinkedHashSet` отличается от `HashSet`?
`LinkedHashSet` отличается от `HashSet` только тем, что в его основе лежит `LinkedHashMap` вместо `HashMap`. Благодаря этому порядок элементов при обходе коллекции является идентичным порядку добавления элементов (insertion-order). При добавлении элемента, который уже присутствует в `LinkedHashSet` (т.е. с одинаковым ключом), порядок обхода элементов не изменяется.

[к оглавлению](#java-collections-framework)

## Для `Enum` есть специальный класс `java.util.EnumSet`. Зачем? Чем авторов не устраивал `HashSet` или `TreeSet`?
`EnumSet` - это реализация интерфейса `Set` для использования с перечислениями (`Enum`). В структуре данных хранятся объекты только одного типа `Enum`, указываемого при создании. Для хранения значений `EnumSet` использует массив битов (_bit vector_), - это позволяет получить высокую компактность и эффективность. Проход по `EnumSet` осуществляется согласно порядку объявления элементов перечисления. 

Все основные операции выполняются за _O(1)_ и обычно (но негарантированно) быстрей аналогов из `HashSet`, а пакетные операции (_bulk operations_), такие как `containsAll()` и `retainAll()` выполняются даже горазда быстрей. 

Помимо всего `EnumSet` предоставляет множество статических методов инициализации для упрощенного и удобного создания экземпляров.

[к оглавлению](#java-collections-framework)

## Какие существуют способы перебирать элементы списка?
+ Цикл с итератором

```java
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    //iterator.next();
}
```

+ Цикл `for`

```java
for (int i = 0; i < list.size(); i++) {
    //list.get(i);
}
```

+ Цикл `while`

```java
int i = 0;
while (i < list.size()) {
	//list.get(i);
	i++;
}
```

+ «for-each»

```java
for (String element : list) {
	//element;
}
```

[к оглавлению](#java-collections-framework)

## Расскажите про интерфейс `Comparable`

Для того, чтобы объекты какого-либо класса можно было сравнить и сортировать, класс должен реализовывать интерфейс `Comparable<E>`. При применении интерфейса он типизируется текущим классом.

Интерфейс `Comparable` содержит один единственный метод int `compareTo(E item)`, который сравнивает текущий объект с объектом, переданным в качестве параметра. 

Если этот метод возвращает отрицательное число, то текущий объект будет располагаться перед тем, который передается через параметр. Если метод вернет положительное число, то, наоборот, после второго объекта. Если метод возвратит ноль, значит, оба объекта равны.

[к оглавлению](#java-collections-framework)

## Расскажите про интерфейс `Comparator`

Если разработчик не реализовал в своем классе интерфейс `Comparable`, или существует небходимость нестандартной сортировки, есть еще более гибкий способ, предполагающий применение интерфейса `Comparator<E>`.
Для этого необходимо создать отдельный класс, который реализует интерфейс `Comparator`.

Интерфейс `Comparator` содержит ряд методов, ключевым из которых является метод `compare()`.
Метод `compare` также возвращает числовое значение - если оно отрицательное, то объект a предшествует объекту b, иначе - наоборот. А если метод возвращает ноль, то объекты равны. Для применения интерфейса нам вначале надо создать класс компаратора, который реализует этот интерфейс.

Для сортировки элементов коллекции с использованием `Comparable`, необходимо вызвать у экземпляра коллекции метод `sort()`, который принимает на вход объект класса, реализующего интерфейс `Comparator`.

[к оглавлению](#java-collections-framework)

## В чем заключаются отличия `java.util.Comparator` от `java.lang.Comparable`?

`Interface Comparable` задает свойство сравнения объекту реализующему его. То есть
делает объект сравнимым (по правилам разработчика).

`Interface Comparator` позволяет создавать объекты, которые будут управлять процессом
сравнения (например при сортировках).

[к оглавлению](#java-collections-framework)

## Какой алгоритм сортировки используется в методе `Collections.sort()`?

`Collections.sort()` использует `TimSort`, гибрид сортировки слияния и вставки (По специальному алгоритму входной массив разделяется на подмассивы. Каждый подмассив сортируется сортировкой вставками. Отсортированные подмассивы собираются в единый массив с помощью модифицированной сортировки слиянием.)
Причина, по которой для сортировки коллекций и массивов комплексных объектов выбран алгоритм сортировки слиянием, заключается в том, что данный алгоритм является устойчивой сортировкой, в отличие от быстрой сортировки, являющейся неустойчивой. Устойчивой сортировкой называется такой алгоритм, который сохраняет порядок следования элементов с одинаковыми ключами сортировки. К примеру, пусть нам требуется отсортировать следующие пары чисел по первому числу пары:

(4, 2)  (3, 7)  (3, 1)  (5, 6)
Тогда на выходе, в зависимости от использованного алгоритма сортировки, мы можем получить два различных результата:

(3, 7)  (3, 1)  (4, 2)  (5, 6)   (порядок сохранен)
(3, 1)  (3, 7)  (4, 2)  (5, 6)   (порядок изменен)
В первом случае пары (3, 7) и (3, 1) с равными ключами сортировки остались в том же порядке следования, как и изначально. Во втором случае они поменялись местами.

Почему важна устойчивая сортировка? Она позволяет производить цепочку последовательных сортировок, добиваясь сортировки в группах и подгруппах коллекции. Покажем, что это означает, на примере (примеры записаны на языке `Scala` для минимизации избыточного кода, присущего `Java`, но смысл будет ясен). Пусть мы имеем структуру данных для представления музыкальных записей:

+ // `albumName` - имя музыкального альбома;
+ // `trackNumber` - номер трека в альбоме.

```java
case class Record(albumName: String, trackNumber: Int)
```
Разместим в списке несколько музыкальных произведений (из дискографии группы Metallica) в произвольном порядке:

```java
val records = List(Record(""Master of Puppets"", 7), Record(""Load"", 4),
                   Record(""Load"", 2), Record(""Reload"", 5),
                   Record(""Load"", 3), Record(""Reload"", 3))
```
Теперь отсортируем записи по номеру трека:
```java
scala> val byTrackNumber = records.sortBy(_.trackNumber)
byTrackNumber: List[Record] = List(Record(Load,2), Record(Load,3), Record(Reload,3), Record(Load,4), Record(Reload,5), Record(Master of Puppets,7))
```
А затем отсортируем еще раз, но уже по имени альбома:
```java
scala> byTrackNumber.sortBy(_.albumName)
res4: List[Record] = List(Record(Load,2), Record(Load,3), Record(Load,4), Record(Master of Puppets,7), Record(Reload,3), Record(Reload,5))
```
Что мы получили? Мы получили список записей, отсортированный по имени альбома, а в каждом альбоме отсортированный по номеру трека! Для этого мы сначала применили сортировку по менее значимому ключу (номер трека), которая сортирует для нас записи в подгруппах (альбомах). Затем сортировку по более значимому ключу - имени альбома. Такая последовательность важна. Следует заметить, что этот результат можно было бы получить, если сразу отсортировать записи по альбому И номеру трека за один раз, но существуют ситуации, когда нам неизвестны заранее все ключи, по которым мы будем сортировать коллекцию. К примеру, пользователь программы может выбрать в графическом интерфейсе сначала сортировку по полю ""номер трека"", а только затем по полю ""альбом"".

В случае, если бы мы применили нестабильную сортировку, вышеуказанный результат не гарантирован. Почему тогда для сортировки примитивов используется быстрая сортировка, являющаяся неустойчивой? Потому что равные примитивы (числа, символы) неотличимы друг от друга при перестановке, в отличие от комплексных объектов. Иными словами, примитивы можно сортировать только по одному ключу (их значениям). Поэтому для них допустимо применить более быстрый алгоритм, коим и является быстрая сортировка."

[к оглавлению](#java-collections-framework)

## Сортировка по нескольким критериям

Интерфейс `Comparator<E>` определяет специальный метод по умолчанию `thenComparing()`, который позволяет использовать цепочки компараторов для сортировки набора:

```java
Comparator<Person> pcomp = new PersonNameComparator().thenComparing(new PersonAgeComparator());
TreeSet<Person> people = new TreeSet(pcomp);
people.add(new Person("Tom", 23));
people.add(new Person("Nick",34));
people.add(new Person("Tom",10));
people.add(new Person("Bill",14));
 
for(Person  p : people){
    System.out.println(p.getName() + " " + p.getAge());
}
```

[к оглавлению](#java-collections-framework)

## Перечислите синхронизированные оболочки

Синхронизированные оболочки добавляют автоматическую синхронизацию (потоко-безопасность) к определенной коллекции. Каждый из шести основных интерфейсов коллекций (`Collection`, `Set`, `List`, `Map`, `SortedSet`, и `SortedMap`) располагает статическим фабричным методом синхронизации.

+ `public static  Collection synchronizedCollection(Collection c)`;
+ `public static  Set synchronizedSet(Set s)`;
+ `public static  List synchronizedList(List list)`;
+ `public static <K,V> Map<K,V> synchronizedMap(Map<K,V> m)`;
+ `public static  SortedSet synchronizedSortedSet(SortedSet s)`;
+ `public static <K,V> SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> m)`;

[к оглавлению](#java-collections-framework)

## Перечислите неизменяемые оболочки

Неизменяемые оболочки/обертки не позволяют изменять коллекцию, перехватывая все операции, которые изменяют коллекции и бросают `UnsupportedOperationException` в том случае, если кто-то захочет это сделать.
 
 Вот эти методы:
+ `public static  Collection unmodifiableCollection(Collection<? extends T> c)`;
+ `public static  Set unmodifiableSet(Set<? extends T> s)`;
+ `public static  List unmodifiableList(List<? extends T> list)`;
+ `public static <K,V> Map<K, V> unmodifiableMap(Map<? extends K, ? extends V> m)`;
+ `public static  SortedSet unmodifiableSortedSet(SortedSet<? extends T> s)`;
+ `public static <K,V> SortedMap<K, V> unmodifiableSortedMap(SortedMap<K, ? extends V> m)`;

[к оглавлению](#java-collections-framework)

## Каким образом можно получить синхронизированные объекты стандартных коллекций?
С помощью статических методов `synchronizedMap()` и `synchronizedList()` класса `Collections`. Данные методы возвращают синхронизированный декоратор переданной коллекции. При этом все равно в случае обхода по коллекции требуется ручная синхронизация. 

```java
  Map m = Collections.synchronizedMap(new HashMap());
  List l = Collections.synchronizedList(new ArrayList());
```

Начиная с Java 6 JCF был расширен специальными коллекциями, поддерживающими многопоточный доступ, такими как `CopyOnWriteArrayList` и `ConcurrentHashMap`.

[к оглавлению](#java-collections-framework)

## Как получить коллекцию только для чтения?
При помощи:

+ `Collections.unmodifiableList(list)`;
+ `Collections.unmodifiableSet(set)`;
+ `Collections.unmodifiableMap(map)`.

Эти методы принимают коллекцию в качестве параметра, и возвращают коллекцию только для чтения с теми же элементами внутри.

[к оглавлению](#java-collections-framework)

## Как сделать потокобезопасную коллекцию?

Используйте следующие методы:

+ `Collections.synchronizedList(list)`;
+ `Collections.synchronizedSet(set)`;
+ `Collections.synchronizedMap(map)`;

Все они принимают коллекцию в качестве параметра, и возвращают потокобезопасную коллекцию с теми же элементами внутри.

[к оглавлению](#java-collections-framework)

## Напишите однопоточную программу, которая заставляет коллекцию выбросить `ConcurrentModificationException`.
```java
public static void main(String[] args) {
    List<Integer> list = new ArrayList<>();
    list.add(1);
    list.add(2);
    list.add(3);

    for (Integer integer : list) {
        list.remove(1);
    }
}
```

[к оглавлению](#java-collections-framework)

## Приведите пример, когда какая-либо коллекция выбрасывает `UnsupportedOperationException`.
```java
public static void main(String[] args) {
    List<Integer> list = Collections.emptyList();
    list.add(0);
}
```

[к оглавлению](#java-collections-framework)

## Реализуйте симметрическую разность двух коллекций используя методы `Collection` (`addAll(...)`, `removeAll(...)`, `retainAll(...)`).
Симметрическая разность двух коллекций - это множество элементов, одновременно не принадлежащих обоим исходным коллекциям.

```java
<T> Collection<T> symmetricDifference(Collection<T> a, Collection<T> b) {    
    // Объединяем коллекции.
    Collection<T> result = new ArrayList<>(a);
    result.addAll(b);
    
    // Получаем пересечение коллекций.
    Collection<T> intersection = new ArrayList<>(a);
    intersection.retainAll(b);
    
    // Удаляем элементы, расположенные в обоих коллекциях.
    result.removeAll(intersection);

    return result;
}
```
[к оглавлению](#java-collections-framework)

## Как, используя LinkedHashMap, сделать кэш c «invalidation policy»?
Необходимо использовать _LRU-алгоритм (Least Recently Used algorithm)_ и `LinkedHashMap` с access-order. В этом случае при обращении к элементу он будет перемещаться в конец списка, а наименее используемые элементы будут постепенно группироваться в начале списка. Так же в стандартной реализации `LinkedHashMap` есть метод `removeEldestEntries()`, который возвращает `true`, если текущий объект `LinkedHashMap` должен удалить наименее используемый элемент из коллекции при использовании методов `put()` и `putAll()`.

```java
public class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private static final int MAX_ENTRIES = 10;

    public LRUCache(int initialCapacity) {
        super(initialCapacity, 0.85f, true);
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > MAX_ENTRIES;
    }
}
```

Стоит заметить, что `LinkedHashMap` не позволяет полностью реализовать LRU-алгоритм, поскольку при вставке уже имеющегося в коллекции элемента порядок итерации по элементам не меняется.

[к оглавлению](#java-collections-framework)

## Как одной строчкой скопировать элементы любой `collection` в массив?
```java
Object[] array = collection.toArray();
```

[к оглавлению](#java-collections-framework)

## Как одним вызовом из `List` получить `List` со всеми элементами, кроме первых и последних 3-х?
```java
List<Integer> subList = list.subList(3, list.size() - 3);
```

[к оглавлению](#java-collections-framework)

## Как одной строчкой преобразовать `HashSet` в `ArrayList`?
```java
ArrayList<Integer> list = new ArrayList<>(new HashSet<>());
```

[к оглавлению](#java-collections-framework)

## Как одной строчкой преобразовать `ArrayList` в `HashSet`?
```java
HashSet<Integer> set = new HashSet<>(new ArrayList<>());
```

[к оглавлению](#java-collections-framework)

## Назовите различия между `HashMap` и `HashSet`?

`HashMap` — коллекция пар ключ/значение, тогда как `HashSet` это упорядоченная коллекция уникальных элементов. И это все, не требуется больше никаких объяснений.

[к оглавлению](#java-collections-framework)

## Сделайте `HashSet` из ключей `HashMap`.
```java
HashSet<Object> set = new HashSet<>(map.keySet());
```

[к оглавлению](#java-collections-framework)

## Сделайте `HashMap` из `HashSet<Map.Entry<K, V>>`.
```java
HashMap<K, V> map = new HashMap<>(set.size());
for (Map.Entry<K, V> entry : set) {
    map.put(entry.getKey(), entry.getValue());
}
```

[к оглавлению](#java-collections-framework)



# Источник
+ [metanit.com](https://metanit.com/java/tutorial)
+ [parshinpn.pro](http://www.parshinpn.pro/content/voprosy-i-otvety-na-sobesedovanii-po-teme-java-collection-framework-chast-1)
+ [Хабрахабр](https://habrahabr.ru/post/162017/)
+ [Quizful](http://www.quizful.net/interview/java)
+ [JavaRush](http://info.javarush.ru/)
+ [Хабрахабр:Справочник по Java Collections Framework](https://habrahabr.ru/post/237043/)

[Вопросы для собеседования](README.md)
